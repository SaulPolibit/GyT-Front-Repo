"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/lp-portal/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/structures-storage.ts":
/*!***************************************!*\
  !*** ./src/lib/structures-storage.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canAddInvestment: () => (/* binding */ canAddInvestment),\n/* harmony export */   canAddInvestor: () => (/* binding */ canAddInvestor),\n/* harmony export */   canAddIssuance: () => (/* binding */ canAddIssuance),\n/* harmony export */   clearStructures: () => (/* binding */ clearStructures),\n/* harmony export */   createSampleHierarchies: () => (/* binding */ createSampleHierarchies),\n/* harmony export */   deleteNavEntry: () => (/* binding */ deleteNavEntry),\n/* harmony export */   deleteStructure: () => (/* binding */ deleteStructure),\n/* harmony export */   getIncomeFlowPath: () => (/* binding */ getIncomeFlowPath),\n/* harmony export */   getStructureAncestors: () => (/* binding */ getStructureAncestors),\n/* harmony export */   getStructureById: () => (/* binding */ getStructureById),\n/* harmony export */   getStructureDescendants: () => (/* binding */ getStructureDescendants),\n/* harmony export */   getStructureHierarchy: () => (/* binding */ getStructureHierarchy),\n/* harmony export */   getStructureInvestmentCount: () => (/* binding */ getStructureInvestmentCount),\n/* harmony export */   getStructureInvestorCount: () => (/* binding */ getStructureInvestorCount),\n/* harmony export */   getStructureIssuanceCount: () => (/* binding */ getStructureIssuanceCount),\n/* harmony export */   getStructureNavHistory: () => (/* binding */ getStructureNavHistory),\n/* harmony export */   getStructures: () => (/* binding */ getStructures),\n/* harmony export */   migrateStructures: () => (/* binding */ migrateStructures),\n/* harmony export */   repairHierarchyRelationships: () => (/* binding */ repairHierarchyRelationships),\n/* harmony export */   saveStructure: () => (/* binding */ saveStructure),\n/* harmony export */   updateStructure: () => (/* binding */ updateStructure),\n/* harmony export */   updateStructureNav: () => (/* binding */ updateStructureNav),\n/* harmony export */   validateHierarchyIntegrity: () => (/* binding */ validateHierarchyIntegrity)\n/* harmony export */ });\n// Investor Pre-Registration Interface\nconst STORAGE_KEY = 'polibit_structures';\n// Helper function to generate URL-safe slug from structure name\nfunction generateSlugFromName(name) {\n    return name.toLowerCase().replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric with hyphens\n    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens\n    ;\n}\n// Get all structures from localStorage\nfunction getStructures() {\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(STORAGE_KEY);\n        if (!stored) return [];\n        const structures = JSON.parse(stored);\n        // Parse dates back to Date objects\n        return structures.map((s)=>{\n            var _s_preRegisteredInvestors, _s_uploadedFundDocuments, _s_uploadedInvestorDocuments;\n            return {\n                ...s,\n                createdDate: new Date(s.createdDate),\n                inceptionDate: s.inceptionDate ? new Date(s.inceptionDate) : undefined,\n                preRegisteredInvestors: (_s_preRegisteredInvestors = s.preRegisteredInvestors) === null || _s_preRegisteredInvestors === void 0 ? void 0 : _s_preRegisteredInvestors.map((inv)=>({\n                        ...inv,\n                        addedAt: new Date(inv.addedAt)\n                    })),\n                uploadedFundDocuments: (_s_uploadedFundDocuments = s.uploadedFundDocuments) === null || _s_uploadedFundDocuments === void 0 ? void 0 : _s_uploadedFundDocuments.map((doc)=>({\n                        ...doc,\n                        addedAt: new Date(doc.addedAt)\n                    })),\n                uploadedInvestorDocuments: (_s_uploadedInvestorDocuments = s.uploadedInvestorDocuments) === null || _s_uploadedInvestorDocuments === void 0 ? void 0 : _s_uploadedInvestorDocuments.map((doc)=>({\n                        ...doc,\n                        addedAt: new Date(doc.addedAt)\n                    }))\n            };\n        });\n    } catch (error) {\n        console.error('Error loading structures:', error);\n        return [];\n    }\n}\n// Save a new structure (can be a single structure or create multi-level hierarchy)\nfunction saveStructure(structure) {\n    // If hierarchyMode is enabled and this is a root structure (no parent), create multi-level hierarchy\n    // Multi-level hierarchy is only supported for Fund, SA/LLC, and Trust (NOT Private Debt)\n    const supportsHierarchy = structure.type === 'fund' || structure.type === 'sa' || structure.type === 'fideicomiso';\n    if (structure.hierarchyMode && !structure.parentStructureId && structure.hierarchyLevel === 1 && supportsHierarchy) {\n        return createMultiLevelStructure(structure);\n    }\n    // If hierarchyMode is requested but structure type doesn't support it, log warning and create single structure\n    if (structure.hierarchyMode && !supportsHierarchy) {\n        console.warn(\"[saveStructure] Multi-level hierarchy not supported for structure type: \".concat(structure.type, \". Creating single structure instead.\"));\n    }\n    // Otherwise, create single structure\n    return saveSingleStructure(structure);\n}\n// Helper: Save a single structure\nfunction saveSingleStructure(structure) {\n    const structures = getStructures();\n    // Generate slug from name\n    let slug = generateSlugFromName(structure.name);\n    // Handle duplicates by appending number\n    let counter = 1;\n    let finalSlug = slug;\n    while(structures.some((s)=>s.id === finalSlug)){\n        finalSlug = \"\".concat(slug, \"-\").concat(counter);\n        counter++;\n    }\n    const newStructure = {\n        ...structure,\n        id: finalSlug,\n        createdDate: new Date()\n    };\n    structures.push(newStructure);\n    // If this structure has a parent, update the parent's childStructureIds\n    if (newStructure.parentStructureId) {\n        const parentIndex = structures.findIndex((s)=>s.id === newStructure.parentStructureId);\n        if (parentIndex !== -1) {\n            if (!structures[parentIndex].childStructureIds) {\n                structures[parentIndex].childStructureIds = [];\n            }\n            if (!structures[parentIndex].childStructureIds.includes(finalSlug)) {\n                structures[parentIndex].childStructureIds.push(finalSlug);\n            }\n        }\n    }\n    try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(structures));\n    } catch (error) {\n        console.error('Error saving structure:', error);\n        throw error;\n    }\n    return newStructure;\n}\n// Helper: Create a multi-level hierarchy (N levels) from a single structure input\nfunction createMultiLevelStructure(baseStructure) {\n    const numberOfLevels = baseStructure.numberOfLevels || 4 // Default to 4 if not specified\n    ;\n    const hierarchyConfig = baseStructure.hierarchyStructures || [];\n    console.log(\"[createMultiLevelStructure] Creating \".concat(numberOfLevels, \"-level hierarchy for: \").concat(baseStructure.name));\n    if (numberOfLevels < 2) {\n        console.warn(\"[createMultiLevelStructure] numberOfLevels must be >= 2. Creating single structure.\");\n        return saveSingleStructure(baseStructure);\n    }\n    if (hierarchyConfig.length === 0) {\n        console.warn(\"[createMultiLevelStructure] No hierarchy configuration provided. Using default settings.\");\n    }\n    const baseSlug = generateSlugFromName(baseStructure.name);\n    const createdLevels = [];\n    let previousLevel = null;\n    // Create N levels dynamically using configuration from hierarchyStructures\n    for(let levelNum = 1; levelNum <= numberOfLevels; levelNum++){\n        // Get configuration for this level (array is 0-indexed, levels are 1-indexed)\n        const levelConfig = hierarchyConfig[levelNum - 1];\n        var _levelConfig_applyEconomicTerms;\n        // Use checkbox values from UI configuration, or fallback to defaults\n        const applyEconomicTerms = (_levelConfig_applyEconomicTerms = levelConfig === null || levelConfig === void 0 ? void 0 : levelConfig.applyEconomicTerms) !== null && _levelConfig_applyEconomicTerms !== void 0 ? _levelConfig_applyEconomicTerms : levelNum <= 2;\n        var _levelConfig_applyWaterfall;\n        const applyWaterfall = (_levelConfig_applyWaterfall = levelConfig === null || levelConfig === void 0 ? void 0 : levelConfig.applyWaterfall) !== null && _levelConfig_applyWaterfall !== void 0 ? _levelConfig_applyWaterfall : levelNum <= 2;\n        var _levelConfig_waterfallAlgorithm;\n        const waterfallAlgo = (_levelConfig_waterfallAlgorithm = levelConfig === null || levelConfig === void 0 ? void 0 : levelConfig.waterfallAlgorithm) !== null && _levelConfig_waterfallAlgorithm !== void 0 ? _levelConfig_waterfallAlgorithm : applyWaterfall ? 'american' : null;\n        // Determine structure type for this level\n        // Use type from hierarchy config if provided, otherwise inherit from master\n        const levelType = (levelConfig === null || levelConfig === void 0 ? void 0 : levelConfig.type) || baseStructure.type;\n        const levelSubtype = baseStructure.subtype;\n        // Generate unique name by appending level label\n        const levelLabel = (levelConfig === null || levelConfig === void 0 ? void 0 : levelConfig.name) || \"Level \".concat(levelNum);\n        const levelName = levelNum === 1 ? baseStructure.name : \"\".concat(baseStructure.name, \" - \").concat(levelLabel);\n        // Build hierarchy path\n        const hierarchyPath = [\n            ...createdLevels.map((l)=>l.id),\n            \"\".concat(baseSlug, \"-level-\").concat(levelNum)\n        ];\n        // Calculate commitment (decreases at each level)\n        const commitmentMultiplier = 1 - (levelNum - 1) * 0.2;\n        const totalCommitment = baseStructure.totalCommitment * Math.max(commitmentMultiplier, 0.3);\n        const levelStructure = saveSingleStructure({\n            ...baseStructure,\n            name: levelName,\n            type: levelType,\n            subtype: levelSubtype,\n            hierarchyLevel: levelNum,\n            hierarchyPath,\n            parentStructureId: (previousLevel === null || previousLevel === void 0 ? void 0 : previousLevel.id) || null,\n            childStructureIds: [],\n            totalCommitment,\n            // Use checkbox values from structure setup UI\n            applyWaterfallAtThisLevel: applyWaterfall,\n            applyEconomicTermsAtThisLevel: applyEconomicTerms,\n            waterfallAlgorithm: waterfallAlgo,\n            incomeFlowTarget: (previousLevel === null || previousLevel === void 0 ? void 0 : previousLevel.id) || 'investors'\n        });\n        createdLevels.push(levelStructure);\n        previousLevel = levelStructure;\n        const investabilityLabel = applyEconomicTerms ? '✅ Investable (Economic Terms)' : '❌ Operational only';\n        const waterfallLabel = applyWaterfall ? \"Waterfall: \".concat(waterfallAlgo) : 'Distribution: Pro-Rata';\n        console.log(\"  ✓ Created Level \".concat(levelNum, \": \").concat(levelStructure.name, \" (ID: \").concat(levelStructure.id, \")\"));\n        console.log(\"    \".concat(investabilityLabel, \" | \").concat(waterfallLabel));\n    }\n    // Repair hierarchy to ensure parent-child relationships are correct\n    repairHierarchyRelationships();\n    // Auto-assign pre-registered investors to investable levels\n    if (baseStructure.preRegisteredInvestors && baseStructure.preRegisteredInvestors.length > 0) {\n        console.log(\"[createMultiLevelStructure] Auto-assigning \".concat(baseStructure.preRegisteredInvestors.length, \" pre-registered investors...\"));\n        const { saveInvestor } = __webpack_require__(/*! ./investors-storage */ \"(app-pages-browser)/./src/lib/investors-storage.ts\");\n        const investableLevels = createdLevels.filter((level)=>level.applyEconomicTermsAtThisLevel);\n        baseStructure.preRegisteredInvestors.forEach((preInvestor)=>{\n            // Determine which level this investor should be assigned to\n            let targetLevel = null;\n            if (preInvestor.hierarchyLevel !== undefined) {\n                // If specific level is set, use that level\n                const foundLevel = createdLevels.find((l)=>l.hierarchyLevel === preInvestor.hierarchyLevel);\n                if (foundLevel && foundLevel.applyEconomicTermsAtThisLevel) {\n                    targetLevel = foundLevel;\n                } else {\n                    console.warn(\"  ⚠ Investor \".concat(preInvestor.email, \" assigned to level \").concat(preInvestor.hierarchyLevel, \" but that level is not investable. Skipping.\"));\n                    return;\n                }\n            } else {\n                // No specific level set, default to first investable level (typically master level)\n                targetLevel = investableLevels[0] || null;\n            }\n            if (!targetLevel) {\n                console.warn(\"  ⚠ No investable level found for investor \".concat(preInvestor.email, \". Skipping.\"));\n                return;\n            }\n            // Create ONE investor record for this pre-registered investor\n            try {\n                // Determine investor name and type based on investorType\n                let investorName;\n                let investorType;\n                if (preInvestor.investorType === 'individual') {\n                    investorName = \"\".concat(preInvestor.firstName, \" \").concat(preInvestor.lastName);\n                    investorType = 'individual';\n                } else {\n                    // Entity investor\n                    investorName = preInvestor.entityName || 'Unknown Entity';\n                    investorType = preInvestor.investorType;\n                }\n                // Pre-registered investors have $0 commitment until they complete onboarding\n                const commitment = 0;\n                const ownershipPercent = 0;\n                saveInvestor({\n                    name: investorName,\n                    email: preInvestor.email,\n                    phone: '',\n                    type: investorType,\n                    status: 'Pending',\n                    fundOwnerships: [\n                        {\n                            fundId: targetLevel.id,\n                            fundName: targetLevel.name,\n                            commitment,\n                            ownershipPercent,\n                            calledCapital: 0,\n                            uncalledCapital: 0,\n                            hierarchyLevel: targetLevel.hierarchyLevel,\n                            investedDate: new Date().toISOString()\n                        }\n                    ],\n                    customTerms: preInvestor.customTerms,\n                    currentValue: 0,\n                    unrealizedGain: 0,\n                    totalDistributed: 0,\n                    netCashFlow: 0,\n                    irr: 0,\n                    taxId: preInvestor.taxId || '',\n                    k1Status: 'Not Started',\n                    country: baseStructure.jurisdiction,\n                    city: '',\n                    address: '',\n                    investorSince: new Date().toISOString(),\n                    // Store entity-specific fields if applicable\n                    ...investorType !== 'individual' && {\n                        entityName: preInvestor.entityName,\n                        entityType: preInvestor.entityType,\n                        contactFirstName: preInvestor.contactFirstName,\n                        contactLastName: preInvestor.contactLastName\n                    }\n                });\n                console.log(\"  ✓ Created \".concat(investorType, \" investor \").concat(preInvestor.email, \" for \").concat(targetLevel.name, \" (Level \").concat(targetLevel.hierarchyLevel, \")\"));\n            } catch (error) {\n                console.error(\"  ✗ Failed to create investor \".concat(preInvestor.email, \":\"), error);\n            }\n        });\n    }\n    console.log(\"[createMultiLevelStructure] ✅ \".concat(numberOfLevels, \"-level hierarchy complete! Root ID: \").concat(createdLevels[0].id));\n    // Return the root structure (Level 1)\n    return createdLevels[0];\n}\n// Update an existing structure\nfunction updateStructure(id, updates) {\n    const structures = getStructures();\n    const index = structures.findIndex((s)=>s.id === id);\n    if (index === -1) return null;\n    structures[index] = {\n        ...structures[index],\n        ...updates\n    };\n    try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(structures));\n    } catch (error) {\n        console.error('Error updating structure:', error);\n        throw error;\n    }\n    return structures[index];\n}\n// Delete a structure and all associated data\nasync function deleteStructure(id) {\n    const structures = getStructures();\n    const structure = structures.find((s)=>s.id === id);\n    if (!structure) return false;\n    try {\n        var _structure_uploadedFundDocuments, _structure_uploadedInvestorDocuments;\n        // 1. If this structure has child structures, delete them recursively first\n        if (structure.childStructureIds && structure.childStructureIds.length > 0) {\n            console.log(\"[deleteStructure] Deleting \".concat(structure.childStructureIds.length, \" child structures for \").concat(structure.name));\n            for (const childId of structure.childStructureIds){\n                await deleteStructure(childId);\n            }\n        }\n        // 2. Delete all investors associated with this structure\n        if (true) {\n            const { getInvestorsByFundId, deleteInvestor } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./investors-storage */ \"(app-pages-browser)/./src/lib/investors-storage.ts\"));\n            const associatedInvestors = getInvestorsByFundId(id);\n            for (const investor of associatedInvestors){\n                deleteInvestor(investor.id);\n            }\n        }\n        // 2.5. Delete all capital calls associated with this structure\n        if (true) {\n            const { getCapitalCallsByFundId, deleteCapitalCall } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_capital-calls-storage_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./capital-calls-storage */ \"(app-pages-browser)/./src/lib/capital-calls-storage.ts\"));\n            const associatedCapitalCalls = getCapitalCallsByFundId(id);\n            for (const capitalCall of associatedCapitalCalls){\n                deleteCapitalCall(capitalCall.id);\n            }\n            console.log(\"[deleteStructure] Deleted \".concat(associatedCapitalCalls.length, \" capital calls for \").concat(structure.name));\n        }\n        // 2.6. Delete all distributions associated with this structure\n        if (true) {\n            const { getDistributionsByFundId, deleteDistribution } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_distributions-storage_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./distributions-storage */ \"(app-pages-browser)/./src/lib/distributions-storage.ts\"));\n            const associatedDistributions = getDistributionsByFundId(id);\n            for (const distribution of associatedDistributions){\n                deleteDistribution(distribution.id);\n            }\n            console.log(\"[deleteStructure] Deleted \".concat(associatedDistributions.length, \" distributions for \").concat(structure.name));\n        }\n        // 3. Delete uploaded documents from filesystem (API call)\n        if (((_structure_uploadedFundDocuments = structure.uploadedFundDocuments) === null || _structure_uploadedFundDocuments === void 0 ? void 0 : _structure_uploadedFundDocuments.length) || ((_structure_uploadedInvestorDocuments = structure.uploadedInvestorDocuments) === null || _structure_uploadedInvestorDocuments === void 0 ? void 0 : _structure_uploadedInvestorDocuments.length)) {\n            try {\n                await fetch(\"/api/structures/\".concat(id, \"/documents\"), {\n                    method: 'DELETE'\n                });\n            } catch (error) {\n                console.warn('Failed to delete uploaded documents:', error);\n            }\n        }\n        // 4. If this structure has a parent, remove it from parent's childStructureIds\n        if (structure.parentStructureId) {\n            const updatedStructures = getStructures();\n            const parent = updatedStructures.find((s)=>s.id === structure.parentStructureId);\n            if (parent && parent.childStructureIds) {\n                parent.childStructureIds = parent.childStructureIds.filter((childId)=>childId !== id);\n                localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedStructures));\n            }\n        }\n        // 5. Delete the structure from localStorage\n        const filtered = getStructures().filter((s)=>s.id !== id);\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(filtered));\n        console.log(\"[deleteStructure] Deleted structure: \".concat(structure.name, \" (\").concat(id, \")\"));\n        return true;\n    } catch (error) {\n        console.error('Error deleting structure:', error);\n        throw error;\n    }\n}\n// Get a single structure by ID\nfunction getStructureById(id) {\n    const structures = getStructures();\n    return structures.find((s)=>s.id === id) || null;\n}\n// Get current investor count for a structure\nfunction getStructureInvestorCount(structureId) {\n    if (false) {}\n    try {\n        const { getInvestorsByFundId } = __webpack_require__(/*! ./investors-storage */ \"(app-pages-browser)/./src/lib/investors-storage.ts\");\n        const investors = getInvestorsByFundId(structureId);\n        return investors.length;\n    } catch (e) {\n        return 0;\n    }\n}\n// Get current investment count for a structure\nfunction getStructureInvestmentCount(structureId) {\n    if (false) {}\n    try {\n        const { getInvestmentsByFundId } = __webpack_require__(/*! ./investments-storage */ \"(app-pages-browser)/./src/lib/investments-storage.ts\");\n        const investments = getInvestmentsByFundId(structureId);\n        return investments.length;\n    } catch (e) {\n        return 0;\n    }\n}\n// Check if structure can accept more investors\nfunction canAddInvestor(structureId) {\n    const structure = getStructureById(structureId);\n    if (!structure) return {\n        canAdd: false,\n        current: 0,\n        max: 0\n    };\n    const current = getStructureInvestorCount(structureId);\n    const max = structure.investors;\n    return {\n        canAdd: current < max,\n        current,\n        max\n    };\n}\n// Check if structure can accept more investments\nfunction canAddInvestment(structureId) {\n    const structure = getStructureById(structureId);\n    if (!structure) return {\n        canAdd: false,\n        current: 0,\n        max: 0\n    };\n    const current = getStructureInvestmentCount(structureId);\n    const max = parseInt(structure.plannedInvestments || '0');\n    return {\n        canAdd: current < max,\n        current,\n        max\n    };\n}\n// Get current issuance count for a structure\nfunction getStructureIssuanceCount(structureId) {\n    if (false) {}\n    try {\n        const { getInvestmentsByFundId } = __webpack_require__(/*! ./investments-storage */ \"(app-pages-browser)/./src/lib/investments-storage.ts\");\n        const investments = getInvestmentsByFundId(structureId);\n        console.log(\"[DEBUG] getStructureIssuanceCount for \".concat(structureId, \":\"), {\n            investmentsFound: investments.length,\n            investments: investments.map((inv)=>({\n                    id: inv.id,\n                    name: inv.name,\n                    fundId: inv.fundId,\n                    investmentType: inv.investmentType\n                }))\n        });\n        // Calculate total issuances based on investment types\n        // Mixed = 2 issuances, Equity = 1, Debt = 1\n        const totalIssuances = investments.reduce((sum, inv)=>{\n            var _inv_investmentType;\n            const invType = (_inv_investmentType = inv.investmentType) === null || _inv_investmentType === void 0 ? void 0 : _inv_investmentType.toUpperCase();\n            if (invType === 'MIXED') return sum + 2;\n            if (invType === 'EQUITY') return sum + 1;\n            if (invType === 'DEBT') return sum + 1;\n            return sum;\n        }, 0);\n        console.log(\"[DEBUG] Total issuances calculated: \".concat(totalIssuances));\n        return totalIssuances;\n    } catch (error) {\n        console.error('[DEBUG] Error in getStructureIssuanceCount:', error);\n        return 0;\n    }\n}\n// Check if structure can accept more issuances (considering the investment type)\nfunction canAddIssuance(structureId, investmentType) {\n    const structure = getStructureById(structureId);\n    if (!structure) return {\n        canAdd: false,\n        current: 0,\n        max: 0,\n        required: 0\n    };\n    const current = getStructureIssuanceCount(structureId);\n    const max = structure.calculatedIssuances || 0;\n    // Calculate how many issuances this investment would require\n    const required = investmentType === 'Mixed' ? 2 : 1;\n    return {\n        canAdd: current + required <= max,\n        current,\n        max,\n        required\n    };\n}\n// Migration function to update old structures with new fields\nfunction migrateStructures() {\n    if (false) {}\n    try {\n        const structures = getStructures();\n        let hasChanges = false;\n        const migratedStructures = structures.map((structure)=>{\n            let needsMigration = false;\n            let migratedStructure = {\n                ...structure\n            };\n            // Migrate SA/LLC subtypes from financing-based to function-based\n            if (structure.type === 'sa' && [\n                'equity',\n                'debt',\n                'mixed'\n            ].includes(structure.subtype)) {\n                hasChanges = true;\n                needsMigration = true;\n                // Default all old subtypes to 'spv' (Single-Property Entity)\n                // This is the most common use case for SA/LLC structures\n                migratedStructure.subtype = 'spv';\n                console.log('Migrated structure \"'.concat(structure.name, '\" from SA/LLC subtype \"').concat(structure.subtype, '\" to \"spv\"'));\n            }\n            // Check if structure needs migration (missing new fields)\n            if (!structure.plannedInvestments) {\n                hasChanges = true;\n                needsMigration = true;\n                // Calculate token value (round to nearest 1000, 10000, 100000)\n                const aum = structure.totalCommitment;\n                const targetTokens = 1000;\n                let tokenValue = Math.round(aum / targetTokens);\n                if (tokenValue >= 100000) tokenValue = Math.round(tokenValue / 100000) * 100000;\n                else if (tokenValue >= 10000) tokenValue = Math.round(tokenValue / 10000) * 10000;\n                else if (tokenValue >= 1000) tokenValue = Math.round(tokenValue / 1000) * 1000;\n                else if (tokenValue >= 100) tokenValue = Math.round(tokenValue / 100) * 100;\n                // Calculate total tokens\n                const totalTokens = Math.round(aum / tokenValue);\n                migratedStructure = {\n                    ...migratedStructure,\n                    // Add default values for V3 fields\n                    plannedInvestments: '1',\n                    financingStrategy: 'equity',\n                    capitalCallNoticePeriod: '10',\n                    capitalCallDefaultPercentage: '25',\n                    capitalCallPaymentDeadline: '15',\n                    determinedTier: structure.totalCommitment <= 10000000 ? 'starter' : structure.totalCommitment <= 50000000 ? 'growth' : structure.totalCommitment <= 100000000 ? 'enterprise' : 'custom',\n                    calculatedIssuances: 1,\n                    tokenName: \"\".concat(structure.name, \" Token\"),\n                    tokenSymbol: structure.name.split(' ').map((w)=>w[0]).join('').substring(0, 5).toUpperCase(),\n                    tokenValue: tokenValue,\n                    totalTokens: totalTokens,\n                    preRegisteredInvestors: [],\n                    uploadedFundDocuments: [],\n                    uploadedInvestorDocuments: []\n                };\n            }\n            // Migrate to hierarchy support (add default values)\n            if (structure.hierarchyMode === undefined) {\n                hasChanges = true;\n                migratedStructure = {\n                    ...migratedStructure,\n                    hierarchyMode: false,\n                    parentStructureId: null,\n                    childStructureIds: [],\n                    hierarchyLevel: 0,\n                    hierarchyPath: [\n                        structure.id\n                    ],\n                    applyWaterfallAtThisLevel: true,\n                    applyEconomicTermsAtThisLevel: true,\n                    waterfallAlgorithm: null,\n                    incomeFlowTarget: 'investors'\n                };\n            }\n            return migratedStructure;\n        });\n        if (hasChanges) {\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(migratedStructures));\n            console.log('Structures migrated successfully');\n        }\n    } catch (error) {\n        console.error('Error migrating structures:', error);\n    }\n}\n// Hierarchy utility functions\n// Get full hierarchy tree starting from root structure\nfunction getStructureHierarchy(rootId) {\n    const structure = getStructureById(rootId);\n    if (!structure) return null;\n    const buildTree = (struct)=>{\n        const children = (struct.childStructureIds || []).map((childId)=>getStructureById(childId)).filter((child)=>child !== null).map((child)=>buildTree(child));\n        return {\n            ...struct,\n            children: children\n        };\n    };\n    return buildTree(structure);\n}\n// Get all ancestor structures up to root\nfunction getStructureAncestors(id) {\n    const structure = getStructureById(id);\n    if (!structure) return [];\n    const ancestors = [];\n    let current = structure;\n    while(current.parentStructureId){\n        const parent = getStructureById(current.parentStructureId);\n        if (!parent) break;\n        ancestors.push(parent);\n        current = parent;\n    }\n    return ancestors.reverse() // Root first\n    ;\n}\n// Get all descendant structures recursively\nfunction getStructureDescendants(id) {\n    const structure = getStructureById(id);\n    if (!structure) {\n        console.log(\"[getStructureDescendants] Structure not found for ID: \".concat(id));\n        return [];\n    }\n    console.log(\"[getStructureDescendants] Starting with: \".concat(structure.name, \" (ID: \").concat(id, \")\"));\n    console.log(\"[getStructureDescendants] childStructureIds:\", structure.childStructureIds);\n    const descendants = [];\n    const collectDescendants = function(struct) {\n        let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        const indent = '  '.repeat(depth);\n        console.log(\"\".concat(indent, \"[collectDescendants] Checking: \").concat(struct.name, \" (Level \").concat(struct.hierarchyLevel, \")\"));\n        console.log(\"\".concat(indent, \"  childStructureIds:\"), struct.childStructureIds);\n        const children = (struct.childStructureIds || []).map((childId)=>{\n            const child = getStructureById(childId);\n            if (!child) {\n                console.log(\"\".concat(indent, \"  WARNING: Child structure not found for ID: \").concat(childId));\n            }\n            return child;\n        }).filter((child)=>child !== null);\n        console.log(\"\".concat(indent, \"  Found \").concat(children.length, \" children\"));\n        children.forEach((child)=>{\n            console.log(\"\".concat(indent, \"  Adding child: \").concat(child.name, \" (Level \").concat(child.hierarchyLevel, \")\"));\n            descendants.push(child);\n            collectDescendants(child, depth + 1);\n        });\n    };\n    collectDescendants(structure);\n    console.log(\"[getStructureDescendants] Total descendants found: \".concat(descendants.length));\n    return descendants;\n}\n// Validate hierarchy integrity (no circular references)\nfunction validateHierarchyIntegrity(id) {\n    const structure = getStructureById(id);\n    if (!structure) return {\n        valid: false,\n        error: 'Structure not found'\n    };\n    // Check for circular references by walking up the tree\n    const visited = new Set();\n    let current = structure;\n    while(current.parentStructureId){\n        if (visited.has(current.id)) {\n            return {\n                valid: false,\n                error: \"Circular reference detected at \".concat(current.name)\n            };\n        }\n        visited.add(current.id);\n        const parent = getStructureById(current.parentStructureId);\n        if (!parent) {\n            return {\n                valid: false,\n                error: \"Parent structure \".concat(current.parentStructureId, \" not found\")\n            };\n        }\n        current = parent;\n    }\n    // Validate hierarchy path matches actual parent chain\n    const ancestors = getStructureAncestors(id);\n    const expectedPath = [\n        ...ancestors.map((a)=>a.id),\n        id\n    ];\n    const actualPath = structure.hierarchyPath || [];\n    if (JSON.stringify(expectedPath) !== JSON.stringify(actualPath)) {\n        return {\n            valid: false,\n            error: 'Hierarchy path mismatch'\n        };\n    }\n    return {\n        valid: true\n    };\n}\n// Get income flow path from property to investors\nfunction getIncomeFlowPath(propertyId) {\n    const structure = getStructureById(propertyId);\n    if (!structure) return {\n        path: [],\n        flowDescription: 'Invalid structure'\n    };\n    const ancestors = getStructureAncestors(propertyId);\n    const path = [\n        structure,\n        ...ancestors\n    ];\n    const flowSteps = path.map((s)=>s.name).join(' → ');\n    const flowDescription = \"\".concat(flowSteps, \" → Investors\");\n    return {\n        path,\n        flowDescription\n    };\n}\n// Repair hierarchy relationships for existing structures\n// This function rebuilds childStructureIds arrays based on parentStructureId references\nfunction repairHierarchyRelationships() {\n    if (false) {}\n    try {\n        const structures = getStructures();\n        const errors = [];\n        let repaired = 0;\n        console.log('[repairHierarchyRelationships] Starting repair...');\n        console.log('[repairHierarchyRelationships] Total structures:', structures.length);\n        // First, initialize all childStructureIds arrays\n        structures.forEach((s)=>{\n            if (!s.childStructureIds) {\n                s.childStructureIds = [];\n            } else {\n                // Clear existing childStructureIds to rebuild from scratch\n                s.childStructureIds = [];\n            }\n        });\n        // Rebuild childStructureIds based on parentStructureId references\n        structures.forEach((structure)=>{\n            if (structure.parentStructureId) {\n                console.log(\"[repairHierarchyRelationships] Processing: \".concat(structure.name));\n                console.log(\"  parentStructureId: \".concat(structure.parentStructureId));\n                console.log(\"  hierarchyLevel: \".concat(structure.hierarchyLevel));\n                const parent = structures.find((s)=>s.id === structure.parentStructureId);\n                if (parent) {\n                    if (!parent.childStructureIds.includes(structure.id)) {\n                        parent.childStructureIds.push(structure.id);\n                        repaired++;\n                        console.log(\"  ✓ Added to parent: \".concat(parent.name));\n                    }\n                } else {\n                    const error = \"Parent structure not found: \".concat(structure.parentStructureId, \" for child \").concat(structure.name);\n                    errors.push(error);\n                    console.error(\"  ✗ \".concat(error));\n                }\n            }\n        });\n        // Save repaired structures\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(structures));\n        console.log('[repairHierarchyRelationships] Repair complete!');\n        console.log(\"  Relationships repaired: \".concat(repaired));\n        console.log(\"  Errors: \".concat(errors.length));\n        return {\n            repaired,\n            errors\n        };\n    } catch (error) {\n        console.error('[repairHierarchyRelationships] Error during repair:', error);\n        throw error;\n    }\n}\n// Create sample multi-level hierarchy structures for testing\nfunction createSampleHierarchies() {\n    if (false) {}\n    console.log('[createSampleHierarchies] Creating sample multi-level hierarchies...');\n    // Get existing structures\n    const existing = getStructures();\n    // Check if hierarchies already exist\n    const hasHierarchies = existing.some((s)=>s.hierarchyMode && s.hierarchyLevel && s.hierarchyLevel > 1);\n    if (hasHierarchies) {\n        console.log('[createSampleHierarchies] Multi-level hierarchies already exist. Skipping creation.');\n        return;\n    }\n    // Create Polibit Real Estate II (4 levels) - Now uses automatic creation!\n    console.log('\\n[createSampleHierarchies] Creating Polibit Real Estate II (4 levels)...');\n    saveStructure({\n        name: 'Polibit Real Estate II',\n        type: 'fideicomiso',\n        subtype: 'real-estate-trust',\n        jurisdiction: 'Panama',\n        totalCommitment: 50000000,\n        currency: 'USD',\n        investors: 80,\n        status: 'active',\n        hierarchyMode: true,\n        hierarchyLevel: 1,\n        applyWaterfallAtThisLevel: true,\n        applyEconomicTermsAtThisLevel: true,\n        waterfallAlgorithm: 'american',\n        incomeFlowTarget: 'investors',\n        managementFee: '2',\n        performanceFee: '20',\n        hurdleRate: '8',\n        preferredReturn: '8',\n        plannedInvestments: '10',\n        calculatedIssuances: 10\n    });\n    // Create Polibit Real Estate III (4 levels) - Now uses automatic creation!\n    console.log('\\n[createSampleHierarchies] Creating Polibit Real Estate III (4 levels)...');\n    saveStructure({\n        name: 'Polibit Real Estate III',\n        type: 'fideicomiso',\n        subtype: 'real-estate-trust',\n        jurisdiction: 'Panama',\n        totalCommitment: 50000000,\n        currency: 'USD',\n        investors: 80,\n        status: 'active',\n        hierarchyMode: true,\n        hierarchyLevel: 1,\n        applyWaterfallAtThisLevel: true,\n        applyEconomicTermsAtThisLevel: true,\n        waterfallAlgorithm: 'american',\n        incomeFlowTarget: 'investors',\n        managementFee: '2',\n        performanceFee: '20',\n        hurdleRate: '8',\n        preferredReturn: '8',\n        plannedInvestments: '10',\n        calculatedIssuances: 10\n    });\n    console.log('\\n[createSampleHierarchies] ✅ Sample hierarchies created successfully!');\n    console.log('  - Polibit Real Estate II: 4 levels (automatic)');\n    console.log('  - Polibit Real Estate III: 4 levels (automatic)');\n    console.log('  - Investable levels: Level 1 and Level 2 (with economic terms & waterfall)');\n    console.log('  - Operational levels: Level 3 and Level 4 (no investor participation)');\n}\nfunction updateStructureNav(structureId, navData) {\n    if (false) {}\n    const structures = getStructures();\n    const index = structures.findIndex((s)=>s.id === structureId);\n    if (index === -1) {\n        console.error('updateStructureNav: Structure not found with ID:', structureId);\n        console.log('Available structure IDs:', structures.map((s)=>s.id));\n        return null;\n    }\n    const structure = structures[index];\n    // Initialize navHistory if it doesn't exist\n    if (!structure.navHistory) {\n        structure.navHistory = [];\n    }\n    // Create new NAV entry\n    const navEntry = {\n        date: new Date().toISOString(),\n        totalNav: navData.totalNav,\n        navPerShare: navData.navPerShare,\n        notes: navData.notes\n    };\n    // Add to history\n    structure.navHistory.push(navEntry);\n    // Update current NAV\n    structure.currentNav = navData.totalNav;\n    // Save to localStorage\n    structures[index] = structure;\n    try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(structures));\n        return structure;\n    } catch (error) {\n        console.error('Error updating NAV:', error);\n        return null;\n    }\n}\nfunction getStructureNavHistory(structureId) {\n    const structure = getStructureById(structureId);\n    if (!structure) return [];\n    return structure.navHistory || [];\n}\nfunction deleteNavEntry(structureId, entryDate) {\n    if (false) {}\n    const structures = getStructures();\n    const index = structures.findIndex((s)=>s.id === structureId);\n    if (index === -1) return false;\n    const structure = structures[index];\n    if (!structure.navHistory) return false;\n    // Filter out the entry with matching date\n    const originalLength = structure.navHistory.length;\n    structure.navHistory = structure.navHistory.filter((entry)=>entry.date !== entryDate);\n    if (structure.navHistory.length === originalLength) return false;\n    // Update currentNav to the latest entry, or undefined if no history\n    if (structure.navHistory.length > 0) {\n        const latestNav = structure.navHistory[structure.navHistory.length - 1];\n        structure.currentNav = latestNav.totalNav;\n    } else {\n        structure.currentNav = undefined;\n    }\n    // Save to localStorage\n    structures[index] = structure;\n    try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(structures));\n        return true;\n    } catch (error) {\n        console.error('Error deleting NAV entry:', error);\n        return false;\n    }\n}\nfunction clearStructures() {\n    if (false) {}\n    localStorage.removeItem(STORAGE_KEY);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3RydWN0dXJlcy1zdG9yYWdlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsc0NBQXNDO0FBeUt0QyxNQUFNQSxjQUFjO0FBRXBCLGdFQUFnRTtBQUNoRSxTQUFTQyxxQkFBcUJDLElBQVk7SUFDeEMsT0FBT0EsS0FDSkMsV0FBVyxHQUNYQyxPQUFPLENBQUMsZUFBZSxLQUFLLHdDQUF3QztLQUNwRUEsT0FBTyxDQUFDLFlBQVksSUFBUyxrQ0FBa0M7O0FBQ3BFO0FBRUEsdUNBQXVDO0FBQ2hDLFNBQVNDO0lBQ2QsSUFBSSxLQUE2QixFQUFFLEVBQVM7SUFFNUMsSUFBSTtRQUNGLE1BQU1DLFNBQVNDLGFBQWFDLE9BQU8sQ0FBQ1I7UUFDcEMsSUFBSSxDQUFDTSxRQUFRLE9BQU8sRUFBRTtRQUV0QixNQUFNRyxhQUFhQyxLQUFLQyxLQUFLLENBQUNMO1FBQzlCLG1DQUFtQztRQUNuQyxPQUFPRyxXQUFXRyxHQUFHLENBQUMsQ0FBQ0M7Z0JBSUdBLDJCQUlEQSwwQkFJSUE7bUJBWk07Z0JBQ2pDLEdBQUdBLENBQUM7Z0JBQ0pDLGFBQWEsSUFBSUMsS0FBS0YsRUFBRUMsV0FBVztnQkFDbkNFLGVBQWVILEVBQUVHLGFBQWEsR0FBRyxJQUFJRCxLQUFLRixFQUFFRyxhQUFhLElBQUlDO2dCQUM3REMsc0JBQXNCLEdBQUVMLDRCQUFBQSxFQUFFSyxzQkFBc0IsY0FBeEJMLGdEQUFBQSwwQkFBMEJELEdBQUcsQ0FBQyxDQUFDTyxNQUFjO3dCQUNuRSxHQUFHQSxHQUFHO3dCQUNOQyxTQUFTLElBQUlMLEtBQUtJLElBQUlDLE9BQU87b0JBQy9CO2dCQUNBQyxxQkFBcUIsR0FBRVIsMkJBQUFBLEVBQUVRLHFCQUFxQixjQUF2QlIsK0NBQUFBLHlCQUF5QkQsR0FBRyxDQUFDLENBQUNVLE1BQWM7d0JBQ2pFLEdBQUdBLEdBQUc7d0JBQ05GLFNBQVMsSUFBSUwsS0FBS08sSUFBSUYs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SUFBSXRCLFVBQVUsQ0FBQyxHQUFHLE9BQU87SUFFekIsTUFBTXBHLFlBQVlsQixVQUFVLENBQUNzSCxNQUFNO0lBRW5DLElBQUksQ0FBQ3BHLFVBQVU4TSxVQUFVLEVBQUUsT0FBTztJQUVsQywwQ0FBMEM7SUFDMUMsTUFBTVUsaUJBQWlCeE4sVUFBVThNLFVBQVUsQ0FBQ25MLE1BQU07SUFDbEQzQixVQUFVOE0sVUFBVSxHQUFHOU0sVUFBVThNLFVBQVUsQ0FBQ3BKLE1BQU0sQ0FBQytKLENBQUFBLFFBQVNBLE1BQU1ULElBQUksS0FBS087SUFFM0UsSUFBSXZOLFVBQVU4TSxVQUFVLENBQUNuTCxNQUFNLEtBQUs2TCxnQkFBZ0IsT0FBTztJQUUzRCxvRUFBb0U7SUFDcEUsSUFBSXhOLFVBQVU4TSxVQUFVLENBQUNuTCxNQUFNLEdBQUcsR0FBRztRQUNuQyxNQUFNK0wsWUFBWTFOLFVBQVU4TSxVQUFVLENBQUM5TSxVQUFVOE0sVUFBVSxDQUFDbkwsTUFBTSxHQUFHLEVBQUU7UUFDdkUzQixVQUFVb04sVUFBVSxHQUFHTSxVQUFVVCxRQUFRO0lBQzNDLE9BQU87UUFDTGpOLFVBQVVvTixVQUFVLEdBQUc5TjtJQUN6QjtJQUVBLHVCQUF1QjtJQUN2QlIsVUFBVSxDQUFDc0gsTUFBTSxHQUFHcEc7SUFDcEIsSUFBSTtRQUNGcEIsYUFBYXdDLE9BQU8sQ0FBQy9DLGFBQWFVLEtBQUtzQyxTQUFTLENBQUN2QztRQUNqRCxPQUFPO0lBQ1QsRUFBRSxPQUFPZSxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyw2QkFBNkJBO1FBQzNDLE9BQU87SUFDVDtBQUNGO0FBRU8sU0FBUzhOO0lBQ2QsSUFBSSxLQUE2QixFQUFFO0lBQ25DL08sYUFBYWdQLFVBQVUsQ0FBQ3ZQO0FBQzFCIiwic291cmNlcyI6WyIvVXNlcnMvbWFyc2FuZW0vRG9jdW1lbnRzL0dpdEh1Yi9kZW1vL3NyYy9saWIvc3RydWN0dXJlcy1zdG9yYWdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEludmVzdG9yIFByZS1SZWdpc3RyYXRpb24gSW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIEludmVzdG9yUHJlUmVnaXN0cmF0aW9uIHtcbiAgLy8gSW52ZXN0b3IgdHlwZVxuICBpbnZlc3RvclR5cGU6ICdpbmRpdmlkdWFsJyB8ICdpbnN0aXR1dGlvbicgfCAnZnVuZC1vZi1mdW5kcycgfCAnZmFtaWx5LW9mZmljZSdcblxuICAvLyBGb3IgaW5kaXZpZHVhbCBpbnZlc3RvcnNcbiAgZmlyc3ROYW1lPzogc3RyaW5nXG4gIGxhc3ROYW1lPzogc3RyaW5nXG5cbiAgLy8gRm9yIGVudGl0eSBpbnZlc3RvcnMgKGluc3RpdHV0aW9uLCBmdW5kLW9mLWZ1bmRzLCBmYW1pbHktb2ZmaWNlKVxuICBlbnRpdHlOYW1lPzogc3RyaW5nXG4gIGVudGl0eVR5cGU/OiBzdHJpbmcgIC8vIExMQywgQ29ycG9yYXRpb24sIFRydXN0LCBQYXJ0bmVyc2hpcCwgZXRjLlxuICBjb250YWN0Rmlyc3ROYW1lPzogc3RyaW5nICAvLyBSZXF1aXJlZCBmb3IgZW50aXRpZXMgLSBwb3J0YWwgdXNlclxuICBjb250YWN0TGFzdE5hbWU/OiBzdHJpbmcgICAvLyBSZXF1aXJlZCBmb3IgZW50aXRpZXMgLSBwb3J0YWwgdXNlclxuICB0YXhJZD86IHN0cmluZyAgLy8gT3B0aW9uYWwgZm9yIGVudGl0aWVzXG5cbiAgLy8gQ29tbW9uIGZpZWxkc1xuICBlbWFpbDogc3RyaW5nXG4gIGhpZXJhcmNoeUxldmVsPzogbnVtYmVyICAvLyBXaGljaCBsZXZlbCAoMC1OKSBpbnZlc3RvciB3aWxsIHBhcnRpY2lwYXRlIGluXG4gIGN1c3RvbVRlcm1zPzoge1xuICAgIG1hbmFnZW1lbnRGZWU/OiBudW1iZXJcbiAgICBwZXJmb3JtYW5jZUZlZT86IG51bWJlclxuICAgIGh1cmRsZVJhdGU/OiBudW1iZXJcbiAgICBwcmVmZXJyZWRSZXR1cm4/OiBudW1iZXJcbiAgfVxuICBzb3VyY2U6ICdtYW51YWwnIHwgJ2NzdidcbiAgYWRkZWRBdDogRGF0ZVxufVxuXG4vLyBTdHJ1Y3R1cmUgZGF0YSB0eXBlXG5leHBvcnQgaW50ZXJmYWNlIFN0cnVjdHVyZSB7XG4gIGlkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHR5cGU6ICdmdW5kJyB8ICdzYScgfCAnZmlkZWljb21pc28nIHwgJ3ByaXZhdGUtZGVidCdcbiAgc3VidHlwZTogc3RyaW5nXG4gIGp1cmlzZGljdGlvbjogc3RyaW5nXG4gIHRvdGFsQ29tbWl0bWVudDogbnVtYmVyXG4gIGN1cnJlbmN5OiBzdHJpbmdcbiAgaW52ZXN0b3JzOiBudW1iZXJcbiAgY3JlYXRlZERhdGU6IERhdGVcbiAgc3RhdHVzOiAnYWN0aXZlJyB8ICdmdW5kcmFpc2luZycgfCAnY2xvc2VkJ1xuICAvLyBBZGRpdGlvbmFsIGZpZWxkcyBmcm9tIG9uYm9hcmRpbmdcbiAgaW5jZXB0aW9uRGF0ZT86IERhdGVcbiAgY3VycmVudFN0YWdlPzogc3RyaW5nXG4gIGZ1bmRUZXJtPzogc3RyaW5nXG4gIGZ1bmRUeXBlPzogc3RyaW5nXG4gIG1pbkNoZWNrU2l6ZT86IG51bWJlclxuICBtYXhDaGVja1NpemU/OiBudW1iZXJcbiAgZWNvbm9taWNUZXJtc0FwcGxpY2F0aW9uPzogc3RyaW5nXG4gIGRpc3RyaWJ1dGlvbk1vZGVsPzogc3RyaW5nXG4gIG1hbmFnZW1lbnRGZWU/OiBzdHJpbmdcbiAgcGVyZm9ybWFuY2VGZWU/OiBzdHJpbmdcbiAgaHVyZGxlUmF0ZT86IHN0cmluZ1xuICBwcmVmZXJyZWRSZXR1cm4/OiBzdHJpbmdcbiAgd2F0ZXJmYWxsU3RydWN0dXJlPzogc3RyaW5nXG4gIGRpc3RyaWJ1dGlvbkZyZXF1ZW5jeT86IHN0cmluZ1xuICBkZWZhdWx0VGF4UmF0ZT86IHN0cmluZ1xuICAvLyBWMyBBZGRpdGlvbmFsIGZpZWxkc1xuICBwbGFubmVkSW52ZXN0bWVudHM/OiBzdHJpbmdcbiAgZmluYW5jaW5nU3RyYXRlZ3k/OiBzdHJpbmdcbiAgdXNTdGF0ZT86IHN0cmluZ1xuICB1c1N0YXRlT3RoZXI/OiBzdHJpbmdcbiAgY2FwaXRhbENhbGxOb3RpY2VQZXJpb2Q/OiBzdHJpbmdcbiAgY2FwaXRhbENhbGxEZWZhdWx0UGVyY2VudGFnZT86IHN0cmluZ1xuICBjYXBpdGFsQ2FsbFBheW1lbnREZWFkbGluZT86IHN0cmluZ1xuICBkZXRlcm1pbmVkVGllcj86IHN0cmluZ1xuICBjYWxjdWxhdGVkSXNzdWFuY2VzPzogbnVtYmVyXG4gIHRva2VuTmFtZT86IHN0cmluZ1xuICB0b2tlblN5bWJvbD86IHN0cmluZ1xuICB0b2tlblZhbHVlPzogbnVtYmVyXG4gIHRvdGFsVG9rZW5zPzogbnVtYmVyXG4gIG1pblRva2Vuc1BlckludmVzdG9yPzogbnVtYmVyXG4gIG1heFRva2Vuc1BlckludmVzdG9yPzogbnVtYmVyXG4gIHByZVJlZ2lzdGVyZWRJbnZlc3RvcnM/OiBJbnZlc3RvclByZVJlZ2lzdHJhdGlvbltdXG4gIHVwbG9hZGVkRnVuZERvY3VtZW50cz86IHsgbmFtZTogc3RyaW5nOyBhZGRlZEF0OiBEYXRlIH1bXVxuICB1cGxvYWRlZEludmVzdG9yRG9jdW1lbnRzPzogeyBuYW1lOiBzdHJpbmc7IGFkZGVkQXQ6IERhdGUgfVtdXG4gIC8vIEhpZXJhcmNoeSBmaWVsZHMgZm9yIG11bHRpLWxldmVsIHN0cnVjdHVyZXNcbiAgaGllcmFyY2h5TW9kZT86IGJvb2xlYW4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUvZGlzYWJsZSBoaWVyYXJjaHkgZmVhdHVyZXNcbiAgbnVtYmVyT2ZMZXZlbHM/OiBudW1iZXIgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgbGV2ZWxzIGluIGhpZXJhcmNoeSAoZS5nLiwgMywgNCwgNSlcbiAgaGllcmFyY2h5U3RydWN0dXJlcz86IHsgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25maWd1cmF0aW9uIGZvciBlYWNoIGxldmVsIGluIGhpZXJhcmNoeVxuICAgIGxldmVsOiBudW1iZXJcbiAgICBuYW1lOiBzdHJpbmdcbiAgICB0eXBlOiBzdHJpbmdcbiAgICBhcHBseVdhdGVyZmFsbDogYm9vbGVhblxuICAgIGFwcGx5RWNvbm9taWNUZXJtczogYm9vbGVhblxuICAgIHdhdGVyZmFsbEFsZ29yaXRobTogJ2FtZXJpY2FuJyB8ICdldXJvcGVhbicgfCBudWxsXG4gIH1bXVxuICBwYXJlbnRTdHJ1Y3R1cmVJZD86IHN0cmluZyB8IG51bGwgICAgICAgICAgICAgIC8vIExpbmsgdG8gcGFyZW50IHN0cnVjdHVyZVxuICBjaGlsZFN0cnVjdHVyZUlkcz86IHN0cmluZ1tdICAgICAgICAgICAgICAgICAgIC8vIEFycmF5IG9mIGNoaWxkIHN0cnVjdHVyZSBJRHNcbiAgaGllcmFyY2h5TGV2ZWw/OiBudW1iZXIgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXB0aCBpbiB0cmVlICgxID0gcm9vdC9tYXN0ZXIsIDIsIDMsIC4uLilcbiAgaGllcmFyY2h5UGF0aD86IHN0cmluZ1tdICAgICAgICAgICAgICAgICAgICAgICAvLyBGdWxsIHBhdGggZnJvbSByb290IHRvIHRoaXMgbm9kZVxuICBhcHBseVdhdGVyZmFsbEF0VGhpc0xldmVsPzogYm9vbGVhbiAgICAgICAgICAgLy8gV2F0ZXJmYWxsIGNhbGN1bGF0aW9ucyBlbmFibGVkIGhlcmVcbiAgYXBwbHlFY29ub21pY1Rlcm1zQXRUaGlzTGV2ZWw/OiBib29sZWFuICAgICAgIC8vIEVjb25vbWljIHRlcm1zIGFwcGx5IGhlcmVcbiAgd2F0ZXJmYWxsQWxnb3JpdGhtPzogJ2FtZXJpY2FuJyB8ICdldXJvcGVhbicgfCBudWxsICAvLyBBbGdvcml0aG0gaWYgZW5hYmxlZFxuICBpbmNvbWVGbG93VGFyZ2V0Pzogc3RyaW5nIHwgbnVsbCAgICAgICAgICAgICAgIC8vIFdoZXJlIGluY29tZSBmbG93cyAocGFyZW50IElEIG9yICdpbnZlc3RvcnMnKVxuICAvLyBJTFBBIFBlcmZvcm1hbmNlIE1ldGhvZG9sb2d5XG4gIHBlcmZvcm1hbmNlTWV0aG9kb2xvZ3k/OiAnZ3JhbnVsYXInIHwgJ2dyb3NzdXAnICAvLyBHcmFudWxhciAoZGV0YWlsZWQgY2FwaXRhbCBjYWxscykgb3IgR3Jvc3MgVXAgKHNpbXBsaWZpZWQpXG4gIGNhbGN1bGF0aW9uTGV2ZWw/OiAnZnVuZC1sZXZlbCcgfCAncG9ydGZvbGlvLWxldmVsJyAgLy8gRnVuZC10by1JbnZlc3RvciBvciBGdW5kLXRvLUludmVzdG1lbnRcbiAgLy8gTkFWIChOZXQgQXNzZXQgVmFsdWUpIFRyYWNraW5nIC0gT3B0aW9uYWxcbiAgY3VycmVudE5hdj86IG51bWJlciAgLy8gTGF0ZXN0IE5BViB2YWx1ZVxuICBuYXZIaXN0b3J5Pzoge1xuICAgIGRhdGU6IHN0cmluZ1xuICAgIHRvdGFsTmF2OiBudW1iZXJcbiAgICBuYXZQZXJTaGFyZT86IG51bWJlclxuICAgIG5vdGVzPzogc3RyaW5nXG4gIH1bXVxuICAvLyBMZWdhbCAmIFRlcm1zIC0gQ29tcHJlaGVuc2l2ZSBsZWdhbCBhZ3JlZW1lbnQgY29udGVudFxuICBsZWdhbFRlcm1zPzoge1xuICAgIC8vIFBhcnRuZXJzaGlwIEFncmVlbWVudCAoMyBjb3JlIHNlY3Rpb25zKVxuICAgIG1hbmFnZW1lbnRDb250cm9sPzogc3RyaW5nXG4gICAgY2FwaXRhbENvbnRyaWJ1dGlvbnM/OiBzdHJpbmdcbiAgICBhbGxvY2F0aW9uc0Rpc3RyaWJ1dGlvbnM/OiBzdHJpbmdcblxuICAgIC8vIExpbWl0ZWQgUGFydG5lciBSaWdodHMgJiBPYmxpZ2F0aW9uc1xuICAgIGxpbWl0ZWRQYXJ0bmVyUmlnaHRzPzogc3RyaW5nW11cbiAgICBsaW1pdGVkUGFydG5lck9ibGlnYXRpb25zPzogc3RyaW5nW11cblxuICAgIC8vIFZvdGluZyBSaWdodHNcbiAgICB2b3RpbmdSaWdodHM/OiB7XG4gICAgICB2b3RpbmdUaHJlc2hvbGQ/OiBudW1iZXJcbiAgICAgIG1hdHRlcnNSZXF1aXJpbmdDb25zZW50Pzogc3RyaW5nW11cbiAgICB9XG5cbiAgICAvLyBSZWRlbXB0aW9uICYgV2l0aGRyYXdhbFxuICAgIHJlZGVtcHRpb25UZXJtcz86IHtcbiAgICAgIGxvY2tVcFBlcmlvZD86IHN0cmluZ1xuICAgICAgd2l0aGRyYXdhbENvbmRpdGlvbnM/OiBzdHJpbmdbXVxuICAgICAgd2l0aGRyYXdhbFByb2Nlc3M/OiBzdHJpbmdbXVxuICAgIH1cblxuICAgIC8vIFRyYW5zZmVyIFJlc3RyaWN0aW9uc1xuICAgIHRyYW5zZmVyUmVzdHJpY3Rpb25zPzoge1xuICAgICAgZ2VuZXJhbFByb2hpYml0aW9uPzogc3RyaW5nXG4gICAgICBwZXJtaXR0ZWRUcmFuc2ZlcnM/OiBzdHJpbmdbXVxuICAgICAgdHJhbnNmZXJSZXF1aXJlbWVudHM/OiBzdHJpbmdbXVxuICAgIH1cblxuICAgIC8vIFJlcG9ydGluZyBDb21taXRtZW50c1xuICAgIHJlcG9ydGluZ0NvbW1pdG1lbnRzPzoge1xuICAgICAgcXVhcnRlcmx5UmVwb3J0cz86IHN0cmluZ1xuICAgICAgYW5udWFsUmVwb3J0cz86IHN0cmluZ1xuICAgICAgdGF4Rm9ybXM/OiBzdHJpbmdcbiAgICAgIGNhcGl0YWxOb3RpY2VzPzogc3RyaW5nXG4gICAgICBhZGRpdGlvbmFsQ29tbXVuaWNhdGlvbnM/OiBzdHJpbmdbXVxuICAgIH1cblxuICAgIC8vIExpYWJpbGl0eSBMaW1pdGF0aW9uc1xuICAgIGxpYWJpbGl0eUxpbWl0YXRpb25zPzoge1xuICAgICAgbGltaXRlZExpYWJpbGl0eVByb3RlY3Rpb24/OiBzdHJpbmdcbiAgICAgIGV4Y2VwdGlvbnNUb0xpbWl0ZWRMaWFiaWxpdHk/OiBzdHJpbmdbXVxuICAgICAgbWF4aW11bUV4cG9zdXJlTm90ZT86IHN0cmluZ1xuICAgIH1cblxuICAgIC8vIEluZGVtbmlmaWNhdGlvblxuICAgIGluZGVtbmlmaWNhdGlvbj86IHtcbiAgICAgIHBhcnRuZXJzaGlwSW5kZW1uaWZpZXNMUEZvcj86IHN0cmluZ1tdXG4gICAgICBscEluZGVtbmlmaWVzUGFydG5lcnNoaXBGb3I/OiBzdHJpbmdbXVxuICAgICAgaW5kZW1uaWZpY2F0aW9uUHJvY2VkdXJlcz86IHN0cmluZ1xuICAgIH1cblxuICAgIC8vIEFkZGl0aW9uYWwgUHJvdmlzaW9ucyAocHJlc2VydmUgZXhpc3RpbmcgZmllbGRzKVxuICAgIGFtZW5kbWVudHM/OiBzdHJpbmdcbiAgICBkaXNzb2x1dGlvbj86IHN0cmluZ1xuICAgIGRpc3B1dGVzPzogc3RyaW5nXG4gICAgZ292ZXJuaW5nTGF3Pzogc3RyaW5nXG4gICAgYWRkaXRpb25hbFByb3Zpc2lvbnM/OiBzdHJpbmdcbiAgfVxufVxuXG5jb25zdCBTVE9SQUdFX0tFWSA9ICdwb2xpYml0X3N0cnVjdHVyZXMnXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBVUkwtc2FmZSBzbHVnIGZyb20gc3RydWN0dXJlIG5hbWVcbmZ1bmN0aW9uIGdlbmVyYXRlU2x1Z0Zyb21OYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBuYW1lXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAucmVwbGFjZSgvW15hLXowLTldKy9nLCAnLScpIC8vIFJlcGxhY2Ugbm9uLWFscGhhbnVtZXJpYyB3aXRoIGh5cGhlbnNcbiAgICAucmVwbGFjZSgvXi0rfC0rJC9nLCAnJykgICAgICAvLyBSZW1vdmUgbGVhZGluZy90cmFpbGluZyBoeXBoZW5zXG59XG5cbi8vIEdldCBhbGwgc3RydWN0dXJlcyBmcm9tIGxvY2FsU3RvcmFnZVxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cnVjdHVyZXMoKTogU3RydWN0dXJlW10ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVkpXG4gICAgaWYgKCFzdG9yZWQpIHJldHVybiBbXVxuXG4gICAgY29uc3Qgc3RydWN0dXJlcyA9IEpTT04ucGFyc2Uoc3RvcmVkKVxuICAgIC8vIFBhcnNlIGRhdGVzIGJhY2sgdG8gRGF0ZSBvYmplY3RzXG4gICAgcmV0dXJuIHN0cnVjdHVyZXMubWFwKChzOiBhbnkpID0+ICh7XG4gICAgICAuLi5zLFxuICAgICAgY3JlYXRlZERhdGU6IG5ldyBEYXRlKHMuY3JlYXRlZERhdGUpLFxuICAgICAgaW5jZXB0aW9uRGF0ZTogcy5pbmNlcHRpb25EYXRlID8gbmV3IERhdGUocy5pbmNlcHRpb25EYXRlKSA6IHVuZGVmaW5lZCxcbiAgICAgIHByZVJlZ2lzdGVyZWRJbnZlc3RvcnM6IHMucHJlUmVnaXN0ZXJlZEludmVzdG9ycz8ubWFwKChpbnY6IGFueSkgPT4gKHtcbiAgICAgICAgLi4uaW52LFxuICAgICAgICBhZGRlZEF0OiBuZXcgRGF0ZShpbnYuYWRkZWRBdClcbiAgICAgIH0pKSxcbiAgICAgIHVwbG9hZGVkRnVuZERvY3VtZW50czogcy51cGxvYWRlZEZ1bmREb2N1bWVudHM/Lm1hcCgoZG9jOiBhbnkpID0+ICh7XG4gICAgICAgIC4uLmRvYyxcbiAgICAgICAgYWRkZWRBdDogbmV3IERhdGUoZG9jLmFkZGVkQXQpXG4gICAgICB9KSksXG4gICAgICB1cGxvYWRlZEludmVzdG9yRG9jdW1lbnRzOiBzLnVwbG9hZGVkSW52ZXN0b3JEb2N1bWVudHM/Lm1hcCgoZG9jOiBhbnkpID0+ICh7XG4gICAgICAgIC4uLmRvYyxcbiAgICAgICAgYWRkZWRBdDogbmV3IERhdGUoZG9jLmFkZGVkQXQpXG4gICAgICB9KSlcbiAgICB9KSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHN0cnVjdHVyZXM6JywgZXJyb3IpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuLy8gU2F2ZSBhIG5ldyBzdHJ1Y3R1cmUgKGNhbiBiZSBhIHNpbmdsZSBzdHJ1Y3R1cmUgb3IgY3JlYXRlIG11bHRpLWxldmVsIGhpZXJhcmNoeSlcbmV4cG9ydCBmdW5jdGlvbiBzYXZlU3RydWN0dXJlKHN0cnVjdHVyZTogT21pdDxTdHJ1Y3R1cmUsICdpZCcgfCAnY3JlYXRlZERhdGUnPik6IFN0cnVjdHVyZSB7XG4gIC8vIElmIGhpZXJhcmNoeU1vZGUgaXMgZW5hYmxlZCBhbmQgdGhpcyBpcyBhIHJvb3Qgc3RydWN0dXJlIChubyBwYXJlbnQpLCBjcmVhdGUgbXVsdGktbGV2ZWwgaGllcmFyY2h5XG4gIC8vIE11bHRpLWxldmVsIGhpZXJhcmNoeSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgRnVuZCwgU0EvTExDLCBhbmQgVHJ1c3QgKE5PVCBQcml2YXRlIERlYnQpXG4gIGNvbnN0IHN1cHBvcnRzSGllcmFyY2h5ID0gc3RydWN0dXJlLnR5cGUgPT09ICdmdW5kJyB8fCBzdHJ1Y3R1cmUudHlwZSA9PT0gJ3NhJyB8fCBzdHJ1Y3R1cmUudHlwZSA9PT0gJ2ZpZGVpY29taXNvJ1xuXG4gIGlmIChzdHJ1Y3R1cmUuaGllcmFyY2h5TW9kZSAmJiAhc3RydWN0dXJlLnBhcmVudFN0cnVjdHVyZUlkICYmIHN0cnVjdHVyZS5oaWVyYXJjaHlMZXZlbCA9PT0gMSAmJiBzdXBwb3J0c0hpZXJhcmNoeSkge1xuICAgIHJldHVybiBjcmVhdGVNdWx0aUxldmVsU3RydWN0dXJlKHN0cnVjdHVyZSlcbiAgfVxuXG4gIC8vIElmIGhpZXJhcmNoeU1vZGUgaXMgcmVxdWVzdGVkIGJ1dCBzdHJ1Y3R1cmUgdHlwZSBkb2Vzbid0IHN1cHBvcnQgaXQsIGxvZyB3YXJuaW5nIGFuZCBjcmVhdGUgc2luZ2xlIHN0cnVjdHVyZVxuICBpZiAoc3RydWN0dXJlLmhpZXJhcmNoeU1vZGUgJiYgIXN1cHBvcnRzSGllcmFyY2h5KSB7XG4gICAgY29uc29sZS53YXJuKGBbc2F2ZVN0cnVjdHVyZV0gTXVsdGktbGV2ZWwgaGllcmFyY2h5IG5vdCBzdXBwb3J0ZWQgZm9yIHN0cnVjdHVyZSB0eXBlOiAke3N0cnVjdHVyZS50eXBlfS4gQ3JlYXRpbmcgc2luZ2xlIHN0cnVjdHVyZSBpbnN0ZWFkLmApXG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBzaW5nbGUgc3RydWN0dXJlXG4gIHJldHVybiBzYXZlU2luZ2xlU3RydWN0dXJlKHN0cnVjdHVyZSlcbn1cblxuLy8gSGVscGVyOiBTYXZlIGEgc2luZ2xlIHN0cnVjdHVyZVxuZnVuY3Rpb24gc2F2ZVNpbmdsZVN0cnVjdHVyZShzdHJ1Y3R1cmU6IE9taXQ8U3RydWN0dXJlLCAnaWQnIHwgJ2NyZWF0ZWREYXRlJz4pOiBTdHJ1Y3R1cmUge1xuICBjb25zdCBzdHJ1Y3R1cmVzID0gZ2V0U3RydWN0dXJlcygpXG5cbiAgLy8gR2VuZXJhdGUgc2x1ZyBmcm9tIG5hbWVcbiAgbGV0IHNsdWcgPSBnZW5lcmF0ZVNsdWdGcm9tTmFtZShzdHJ1Y3R1cmUubmFtZSlcblxuICAvLyBIYW5kbGUgZHVwbGljYXRlcyBieSBhcHBlbmRpbmcgbnVtYmVyXG4gIGxldCBjb3VudGVyID0gMVxuICBsZXQgZmluYWxTbHVnID0gc2x1Z1xuICB3aGlsZSAoc3RydWN0dXJlcy5zb21lKHMgPT4gcy5pZCA9PT0gZmluYWxTbHVnKSkge1xuICAgIGZpbmFsU2x1ZyA9IGAke3NsdWd9LSR7Y291bnRlcn1gXG4gICAgY291bnRlcisrXG4gIH1cblxuICBjb25zdCBuZXdTdHJ1Y3R1cmU6IFN0cnVjdHVyZSA9IHtcbiAgICAuLi5zdHJ1Y3R1cmUsXG4gICAgaWQ6IGZpbmFsU2x1ZyxcbiAgICBjcmVhdGVkRGF0ZTogbmV3IERhdGUoKSxcbiAgfVxuXG4gIHN0cnVjdHVyZXMucHVzaChuZXdTdHJ1Y3R1cmUpXG5cbiAgLy8gSWYgdGhpcyBzdHJ1Y3R1cmUgaGFzIGEgcGFyZW50LCB1cGRhdGUgdGhlIHBhcmVudCdzIGNoaWxkU3RydWN0dXJlSWRzXG4gIGlmIChuZXdTdHJ1Y3R1cmUucGFyZW50U3RydWN0dXJlSWQpIHtcbiAgICBjb25zdCBwYXJlbnRJbmRleCA9IHN0cnVjdHVyZXMuZmluZEluZGV4KHMgPT4gcy5pZCA9PT0gbmV3U3RydWN0dXJlLnBhcmVudFN0cnVjdHVyZUlkKVxuICAgIGlmIChwYXJlbnRJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmICghc3RydWN0dXJlc1twYXJlbnRJbmRleF0uY2hpbGRTdHJ1Y3R1cmVJZHMpIHtcbiAgICAgICAgc3RydWN0dXJlc1twYXJlbnRJbmRleF0uY2hpbGRTdHJ1Y3R1cmVJZHMgPSBbXVxuICAgICAgfVxuICAgICAgaWYgKCFzdHJ1Y3R1cmVzW3BhcmVudEluZGV4XS5jaGlsZFN0cnVjdHVyZUlkcyEuaW5jbHVkZXMoZmluYWxTbHVnKSkge1xuICAgICAgICBzdHJ1Y3R1cmVzW3BhcmVudEluZGV4XS5jaGlsZFN0cnVjdHVyZUlkcyEucHVzaChmaW5hbFNsdWcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoc3RydWN0dXJlcykpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHN0cnVjdHVyZTonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgcmV0dXJuIG5ld1N0cnVjdHVyZVxufVxuXG4vLyBIZWxwZXI6IENyZWF0ZSBhIG11bHRpLWxldmVsIGhpZXJhcmNoeSAoTiBsZXZlbHMpIGZyb20gYSBzaW5nbGUgc3RydWN0dXJlIGlucHV0XG5mdW5jdGlvbiBjcmVhdGVNdWx0aUxldmVsU3RydWN0dXJlKGJhc2VTdHJ1Y3R1cmU6IE9taXQ8U3RydWN0dXJlLCAnaWQnIHwgJ2NyZWF0ZWREYXRlJz4pOiBTdHJ1Y3R1cmUge1xuICBjb25zdCBudW1iZXJPZkxldmVscyA9IGJhc2VTdHJ1Y3R1cmUubnVtYmVyT2ZMZXZlbHMgfHwgNCAvLyBEZWZhdWx0IHRvIDQgaWYgbm90IHNwZWNpZmllZFxuICBjb25zdCBoaWVyYXJjaHlDb25maWcgPSBiYXNlU3RydWN0dXJlLmhpZXJhcmNoeVN0cnVjdHVyZXMgfHwgW11cblxuICBjb25zb2xlLmxvZyhgW2NyZWF0ZU11bHRpTGV2ZWxTdHJ1Y3R1cmVdIENyZWF0aW5nICR7bnVtYmVyT2ZMZXZlbHN9LWxldmVsIGhpZXJhcmNoeSBmb3I6ICR7YmFzZVN0cnVjdHVyZS5uYW1lfWApXG5cbiAgaWYgKG51bWJlck9mTGV2ZWxzIDwgMikge1xuICAgIGNvbnNvbGUud2FybihgW2NyZWF0ZU11bHRpTGV2ZWxTdHJ1Y3R1cmVdIG51bWJlck9mTGV2ZWxzIG11c3QgYmUgPj0gMi4gQ3JlYXRpbmcgc2luZ2xlIHN0cnVjdHVyZS5gKVxuICAgIHJldHVybiBzYXZlU2luZ2xlU3RydWN0dXJlKGJhc2VTdHJ1Y3R1cmUpXG4gIH1cblxuICBpZiAoaGllcmFyY2h5Q29uZmlnLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUud2FybihgW2NyZWF0ZU11bHRpTGV2ZWxTdHJ1Y3R1cmVdIE5vIGhpZXJhcmNoeSBjb25maWd1cmF0aW9uIHByb3ZpZGVkLiBVc2luZyBkZWZhdWx0IHNldHRpbmdzLmApXG4gIH1cblxuICBjb25zdCBiYXNlU2x1ZyA9IGdlbmVyYXRlU2x1Z0Zyb21OYW1lKGJhc2VTdHJ1Y3R1cmUubmFtZSlcbiAgY29uc3QgY3JlYXRlZExldmVsczogU3RydWN0dXJlW10gPSBbXVxuICBsZXQgcHJldmlvdXNMZXZlbDogU3RydWN0dXJlIHwgbnVsbCA9IG51bGxcblxuICAvLyBDcmVhdGUgTiBsZXZlbHMgZHluYW1pY2FsbHkgdXNpbmcgY29uZmlndXJhdGlvbiBmcm9tIGhpZXJhcmNoeVN0cnVjdHVyZXNcbiAgZm9yIChsZXQgbGV2ZWxOdW0gPSAxOyBsZXZlbE51bSA8PSBudW1iZXJPZkxldmVsczsgbGV2ZWxOdW0rKykge1xuICAgIC8vIEdldCBjb25maWd1cmF0aW9uIGZvciB0aGlzIGxldmVsIChhcnJheSBpcyAwLWluZGV4ZWQsIGxldmVscyBhcmUgMS1pbmRleGVkKVxuICAgIGNvbnN0IGxldmVsQ29uZmlnID0gaGllcmFyY2h5Q29uZmlnW2xldmVsTnVtIC0gMV1cblxuICAgIC8vIFVzZSBjaGVja2JveCB2YWx1ZXMgZnJvbSBVSSBjb25maWd1cmF0aW9uLCBvciBmYWxsYmFjayB0byBkZWZhdWx0c1xuICAgIGNvbnN0IGFwcGx5RWNvbm9taWNUZXJtcyA9IGxldmVsQ29uZmlnPy5hcHBseUVjb25vbWljVGVybXMgPz8gKGxldmVsTnVtIDw9IDIpXG4gICAgY29uc3QgYXBwbHlXYXRlcmZhbGwgPSBsZXZlbENvbmZpZz8uYXBwbHlXYXRlcmZhbGwgPz8gKGxldmVsTnVtIDw9IDIpXG4gICAgY29uc3Qgd2F0ZXJmYWxsQWxnbyA9IGxldmVsQ29uZmlnPy53YXRlcmZhbGxBbGdvcml0aG0gPz8gKGFwcGx5V2F0ZXJmYWxsID8gJ2FtZXJpY2FuJyA6IG51bGwpXG5cbiAgICAvLyBEZXRlcm1pbmUgc3RydWN0dXJlIHR5cGUgZm9yIHRoaXMgbGV2ZWxcbiAgICAvLyBVc2UgdHlwZSBmcm9tIGhpZXJhcmNoeSBjb25maWcgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBpbmhlcml0IGZyb20gbWFzdGVyXG4gICAgY29uc3QgbGV2ZWxUeXBlID0gbGV2ZWxDb25maWc/LnR5cGUgfHwgYmFzZVN0cnVjdHVyZS50eXBlXG4gICAgY29uc3QgbGV2ZWxTdWJ0eXBlID0gYmFzZVN0cnVjdHVyZS5zdWJ0eXBlXG5cbiAgICAvLyBHZW5lcmF0ZSB1bmlxdWUgbmFtZSBieSBhcHBlbmRpbmcgbGV2ZWwgbGFiZWxcbiAgICBjb25zdCBsZXZlbExhYmVsID0gbGV2ZWxDb25maWc/Lm5hbWUgfHwgYExldmVsICR7bGV2ZWxOdW19YFxuICAgIGNvbnN0IGxldmVsTmFtZSA9IGxldmVsTnVtID09PSAxXG4gICAgICA/IGJhc2VTdHJ1Y3R1cmUubmFtZVxuICAgICAgOiBgJHtiYXNlU3RydWN0dXJlLm5hbWV9IC0gJHtsZXZlbExhYmVsfWBcblxuICAgIC8vIEJ1aWxkIGhpZXJhcmNoeSBwYXRoXG4gICAgY29uc3QgaGllcmFyY2h5UGF0aCA9IFsuLi5jcmVhdGVkTGV2ZWxzLm1hcChsID0+IGwuaWQpLCBgJHtiYXNlU2x1Z30tbGV2ZWwtJHtsZXZlbE51bX1gXVxuXG4gICAgLy8gQ2FsY3VsYXRlIGNvbW1pdG1lbnQgKGRlY3JlYXNlcyBhdCBlYWNoIGxldmVsKVxuICAgIGNvbnN0IGNvbW1pdG1lbnRNdWx0aXBsaWVyID0gMSAtIChsZXZlbE51bSAtIDEpICogMC4yXG4gICAgY29uc3QgdG90YWxDb21taXRtZW50ID0gYmFzZVN0cnVjdHVyZS50b3RhbENvbW1pdG1lbnQgKiBNYXRoLm1heChjb21taXRtZW50TXVsdGlwbGllciwgMC4zKVxuXG4gICAgY29uc3QgbGV2ZWxTdHJ1Y3R1cmUgPSBzYXZlU2luZ2xlU3RydWN0dXJlKHtcbiAgICAgIC4uLmJhc2VTdHJ1Y3R1cmUsXG4gICAgICBuYW1lOiBsZXZlbE5hbWUsXG4gICAgICB0eXBlOiBsZXZlbFR5cGUsXG4gICAgICBzdWJ0eXBlOiBsZXZlbFN1YnR5cGUsXG4gICAgICBoaWVyYXJjaHlMZXZlbDogbGV2ZWxOdW0sXG4gICAgICBoaWVyYXJjaHlQYXRoLFxuICAgICAgcGFyZW50U3RydWN0dXJlSWQ6IHByZXZpb3VzTGV2ZWw/LmlkIHx8IG51bGwsXG4gICAgICBjaGlsZFN0cnVjdHVyZUlkczogW10sXG4gICAgICB0b3RhbENvbW1pdG1lbnQsXG4gICAgICAvLyBVc2UgY2hlY2tib3ggdmFsdWVzIGZyb20gc3RydWN0dXJlIHNldHVwIFVJXG4gICAgICBhcHBseVdhdGVyZmFsbEF0VGhpc0xldmVsOiBhcHBseVdhdGVyZmFsbCxcbiAgICAgIGFwcGx5RWNvbm9taWNUZXJtc0F0VGhpc0xldmVsOiBhcHBseUVjb25vbWljVGVybXMsXG4gICAgICB3YXRlcmZhbGxBbGdvcml0aG06IHdhdGVyZmFsbEFsZ28sXG4gICAgICBpbmNvbWVGbG93VGFyZ2V0OiBwcmV2aW91c0xldmVsPy5pZCB8fCAnaW52ZXN0b3JzJyxcbiAgICB9KVxuXG4gICAgY3JlYXRlZExldmVscy5wdXNoKGxldmVsU3RydWN0dXJlKVxuICAgIHByZXZpb3VzTGV2ZWwgPSBsZXZlbFN0cnVjdHVyZVxuXG4gICAgY29uc3QgaW52ZXN0YWJpbGl0eUxhYmVsID0gYXBwbHlFY29ub21pY1Rlcm1zID8gJ+KchSBJbnZlc3RhYmxlIChFY29ub21pYyBUZXJtcyknIDogJ+KdjCBPcGVyYXRpb25hbCBvbmx5J1xuICAgIGNvbnN0IHdhdGVyZmFsbExhYmVsID0gYXBwbHlXYXRlcmZhbGwgPyBgV2F0ZXJmYWxsOiAke3dhdGVyZmFsbEFsZ299YCA6ICdEaXN0cmlidXRpb246IFByby1SYXRhJ1xuICAgIGNvbnNvbGUubG9nKGAgIOKckyBDcmVhdGVkIExldmVsICR7bGV2ZWxOdW19OiAke2xldmVsU3RydWN0dXJlLm5hbWV9IChJRDogJHtsZXZlbFN0cnVjdHVyZS5pZH0pYClcbiAgICBjb25zb2xlLmxvZyhgICAgICR7aW52ZXN0YWJpbGl0eUxhYmVsfSB8ICR7d2F0ZXJmYWxsTGFiZWx9YClcbiAgfVxuXG4gIC8vIFJlcGFpciBoaWVyYXJjaHkgdG8gZW5zdXJlIHBhcmVudC1jaGlsZCByZWxhdGlvbnNoaXBzIGFyZSBjb3JyZWN0XG4gIHJlcGFpckhpZXJhcmNoeVJlbGF0aW9uc2hpcHMoKVxuXG4gIC8vIEF1dG8tYXNzaWduIHByZS1yZWdpc3RlcmVkIGludmVzdG9ycyB0byBpbnZlc3RhYmxlIGxldmVsc1xuICBpZiAoYmFzZVN0cnVjdHVyZS5wcmVSZWdpc3RlcmVkSW52ZXN0b3JzICYmIGJhc2VTdHJ1Y3R1cmUucHJlUmVnaXN0ZXJlZEludmVzdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgY29uc29sZS5sb2coYFtjcmVhdGVNdWx0aUxldmVsU3RydWN0dXJlXSBBdXRvLWFzc2lnbmluZyAke2Jhc2VTdHJ1Y3R1cmUucHJlUmVnaXN0ZXJlZEludmVzdG9ycy5sZW5ndGh9IHByZS1yZWdpc3RlcmVkIGludmVzdG9ycy4uLmApXG5cbiAgICBjb25zdCB7IHNhdmVJbnZlc3RvciB9ID0gcmVxdWlyZSgnLi9pbnZlc3RvcnMtc3RvcmFnZScpXG4gICAgY29uc3QgaW52ZXN0YWJsZUxldmVscyA9IGNyZWF0ZWRMZXZlbHMuZmlsdGVyKGxldmVsID0+IGxldmVsLmFwcGx5RWNvbm9taWNUZXJtc0F0VGhpc0xldmVsKVxuXG4gICAgYmFzZVN0cnVjdHVyZS5wcmVSZWdpc3RlcmVkSW52ZXN0b3JzLmZvckVhY2goKHByZUludmVzdG9yKSA9PiB7XG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggbGV2ZWwgdGhpcyBpbnZlc3RvciBzaG91bGQgYmUgYXNzaWduZWQgdG9cbiAgICAgIGxldCB0YXJnZXRMZXZlbDogU3RydWN0dXJlIHwgbnVsbCA9IG51bGxcblxuICAgICAgaWYgKHByZUludmVzdG9yLmhpZXJhcmNoeUxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgc3BlY2lmaWMgbGV2ZWwgaXMgc2V0LCB1c2UgdGhhdCBsZXZlbFxuICAgICAgICBjb25zdCBmb3VuZExldmVsID0gY3JlYXRlZExldmVscy5maW5kKGwgPT4gbC5oaWVyYXJjaHlMZXZlbCA9PT0gcHJlSW52ZXN0b3IuaGllcmFyY2h5TGV2ZWwpXG4gICAgICAgIGlmIChmb3VuZExldmVsICYmIGZvdW5kTGV2ZWwuYXBwbHlFY29ub21pY1Rlcm1zQXRUaGlzTGV2ZWwpIHtcbiAgICAgICAgICB0YXJnZXRMZXZlbCA9IGZvdW5kTGV2ZWxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYCAg4pqgIEludmVzdG9yICR7cHJlSW52ZXN0b3IuZW1haWx9IGFzc2lnbmVkIHRvIGxldmVsICR7cHJlSW52ZXN0b3IuaGllcmFyY2h5TGV2ZWx9IGJ1dCB0aGF0IGxldmVsIGlzIG5vdCBpbnZlc3RhYmxlLiBTa2lwcGluZy5gKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBzcGVjaWZpYyBsZXZlbCBzZXQsIGRlZmF1bHQgdG8gZmlyc3QgaW52ZXN0YWJsZSBsZXZlbCAodHlwaWNhbGx5IG1hc3RlciBsZXZlbClcbiAgICAgICAgdGFyZ2V0TGV2ZWwgPSBpbnZlc3RhYmxlTGV2ZWxzWzBdIHx8IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKCF0YXJnZXRMZXZlbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYCAg4pqgIE5vIGludmVzdGFibGUgbGV2ZWwgZm91bmQgZm9yIGludmVzdG9yICR7cHJlSW52ZXN0b3IuZW1haWx9LiBTa2lwcGluZy5gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIE9ORSBpbnZlc3RvciByZWNvcmQgZm9yIHRoaXMgcHJlLXJlZ2lzdGVyZWQgaW52ZXN0b3JcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIERldGVybWluZSBpbnZlc3RvciBuYW1lIGFuZCB0eXBlIGJhc2VkIG9uIGludmVzdG9yVHlwZVxuICAgICAgICBsZXQgaW52ZXN0b3JOYW1lOiBzdHJpbmdcbiAgICAgICAgbGV0IGludmVzdG9yVHlwZTogJ2luZGl2aWR1YWwnIHwgJ2luc3RpdHV0aW9uJyB8ICdmdW5kLW9mLWZ1bmRzJyB8ICdmYW1pbHktb2ZmaWNlJ1xuXG4gICAgICAgIGlmIChwcmVJbnZlc3Rvci5pbnZlc3RvclR5cGUgPT09ICdpbmRpdmlkdWFsJykge1xuICAgICAgICAgIGludmVzdG9yTmFtZSA9IGAke3ByZUludmVzdG9yLmZpcnN0TmFtZX0gJHtwcmVJbnZlc3Rvci5sYXN0TmFtZX1gXG4gICAgICAgICAgaW52ZXN0b3JUeXBlID0gJ2luZGl2aWR1YWwnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRW50aXR5IGludmVzdG9yXG4gICAgICAgICAgaW52ZXN0b3JOYW1lID0gcHJlSW52ZXN0b3IuZW50aXR5TmFtZSB8fCAnVW5rbm93biBFbnRpdHknXG4gICAgICAgICAgaW52ZXN0b3JUeXBlID0gcHJlSW52ZXN0b3IuaW52ZXN0b3JUeXBlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmUtcmVnaXN0ZXJlZCBpbnZlc3RvcnMgaGF2ZSAkMCBjb21taXRtZW50IHVudGlsIHRoZXkgY29tcGxldGUgb25ib2FyZGluZ1xuICAgICAgICBjb25zdCBjb21taXRtZW50ID0gMFxuICAgICAgICBjb25zdCBvd25lcnNoaXBQZXJjZW50ID0gMFxuXG4gICAgICAgIHNhdmVJbnZlc3Rvcih7XG4gICAgICAgICAgbmFtZTogaW52ZXN0b3JOYW1lLFxuICAgICAgICAgIGVtYWlsOiBwcmVJbnZlc3Rvci5lbWFpbCxcbiAgICAgICAgICBwaG9uZTogJycsXG4gICAgICAgICAgdHlwZTogaW52ZXN0b3JUeXBlLFxuICAgICAgICAgIHN0YXR1czogJ1BlbmRpbmcnLCAvLyBQcmUtcmVnaXN0ZXJlZCBpbnZlc3RvcnMgYXJlIFBlbmRpbmcgdW50aWwgdGhleSBjb21wbGV0ZSBvbmJvYXJkaW5nXG4gICAgICAgICAgZnVuZE93bmVyc2hpcHM6IFt7XG4gICAgICAgICAgICBmdW5kSWQ6IHRhcmdldExldmVsLmlkLFxuICAgICAgICAgICAgZnVuZE5hbWU6IHRhcmdldExldmVsLm5hbWUsXG4gICAgICAgICAgICBjb21taXRtZW50LFxuICAgICAgICAgICAgb3duZXJzaGlwUGVyY2VudCxcbiAgICAgICAgICAgIGNhbGxlZENhcGl0YWw6IDAsXG4gICAgICAgICAgICB1bmNhbGxlZENhcGl0YWw6IDAsXG4gICAgICAgICAgICBoaWVyYXJjaHlMZXZlbDogdGFyZ2V0TGV2ZWwuaGllcmFyY2h5TGV2ZWwsXG4gICAgICAgICAgICBpbnZlc3RlZERhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGN1c3RvbVRlcm1zOiBwcmVJbnZlc3Rvci5jdXN0b21UZXJtcyxcbiAgICAgICAgICBjdXJyZW50VmFsdWU6IDAsXG4gICAgICAgICAgdW5yZWFsaXplZEdhaW46IDAsXG4gICAgICAgICAgdG90YWxEaXN0cmlidXRlZDogMCxcbiAgICAgICAgICBuZXRDYXNoRmxvdzogMCxcbiAgICAgICAgICBpcnI6IDAsXG4gICAgICAgICAgdGF4SWQ6IHByZUludmVzdG9yLnRheElkIHx8ICcnLFxuICAgICAgICAgIGsxU3RhdHVzOiAnTm90IFN0YXJ0ZWQnLCAvLyBDb25zaXN0ZW50IHdpdGggb3RoZXIgcHJlLXJlZ2lzdGVyZWQgaW52ZXN0b3JzXG4gICAgICAgICAgY291bnRyeTogYmFzZVN0cnVjdHVyZS5qdXJpc2RpY3Rpb24sXG4gICAgICAgICAgY2l0eTogJycsXG4gICAgICAgICAgYWRkcmVzczogJycsXG4gICAgICAgICAgaW52ZXN0b3JTaW5jZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIC8vIFN0b3JlIGVudGl0eS1zcGVjaWZpYyBmaWVsZHMgaWYgYXBwbGljYWJsZVxuICAgICAgICAgIC4uLihpbnZlc3RvclR5cGUgIT09ICdpbmRpdmlkdWFsJyAmJiB7XG4gICAgICAgICAgICBlbnRpdHlOYW1lOiBwcmVJbnZlc3Rvci5lbnRpdHlOYW1lLFxuICAgICAgICAgICAgZW50aXR5VHlwZTogcHJlSW52ZXN0b3IuZW50aXR5VHlwZSxcbiAgICAgICAgICAgIGNvbnRhY3RGaXJzdE5hbWU6IHByZUludmVzdG9yLmNvbnRhY3RGaXJzdE5hbWUsXG4gICAgICAgICAgICBjb250YWN0TGFzdE5hbWU6IHByZUludmVzdG9yLmNvbnRhY3RMYXN0TmFtZSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zb2xlLmxvZyhgICDinJMgQ3JlYXRlZCAke2ludmVzdG9yVHlwZX0gaW52ZXN0b3IgJHtwcmVJbnZlc3Rvci5lbWFpbH0gZm9yICR7dGFyZ2V0TGV2ZWwubmFtZX0gKExldmVsICR7dGFyZ2V0TGV2ZWwuaGllcmFyY2h5TGV2ZWx9KWApXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGAgIOKclyBGYWlsZWQgdG8gY3JlYXRlIGludmVzdG9yICR7cHJlSW52ZXN0b3IuZW1haWx9OmAsIGVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjb25zb2xlLmxvZyhgW2NyZWF0ZU11bHRpTGV2ZWxTdHJ1Y3R1cmVdIOKchSAke251bWJlck9mTGV2ZWxzfS1sZXZlbCBoaWVyYXJjaHkgY29tcGxldGUhIFJvb3QgSUQ6ICR7Y3JlYXRlZExldmVsc1swXS5pZH1gKVxuXG4gIC8vIFJldHVybiB0aGUgcm9vdCBzdHJ1Y3R1cmUgKExldmVsIDEpXG4gIHJldHVybiBjcmVhdGVkTGV2ZWxzWzBdXG59XG5cbi8vIFVwZGF0ZSBhbiBleGlzdGluZyBzdHJ1Y3R1cmVcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTdHJ1Y3R1cmUoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxTdHJ1Y3R1cmU+KTogU3RydWN0dXJlIHwgbnVsbCB7XG4gIGNvbnN0IHN0cnVjdHVyZXMgPSBnZXRTdHJ1Y3R1cmVzKClcbiAgY29uc3QgaW5kZXggPSBzdHJ1Y3R1cmVzLmZpbmRJbmRleChzID0+IHMuaWQgPT09IGlkKVxuXG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBudWxsXG5cbiAgc3RydWN0dXJlc1tpbmRleF0gPSB7IC4uLnN0cnVjdHVyZXNbaW5kZXhdLCAuLi51cGRhdGVzIH1cblxuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzdHJ1Y3R1cmVzKSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBzdHJ1Y3R1cmU6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIHJldHVybiBzdHJ1Y3R1cmVzW2luZGV4XVxufVxuXG4vLyBEZWxldGUgYSBzdHJ1Y3R1cmUgYW5kIGFsbCBhc3NvY2lhdGVkIGRhdGFcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVTdHJ1Y3R1cmUoaWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBzdHJ1Y3R1cmVzID0gZ2V0U3RydWN0dXJlcygpXG4gIGNvbnN0IHN0cnVjdHVyZSA9IHN0cnVjdHVyZXMuZmluZChzID0+IHMuaWQgPT09IGlkKVxuXG4gIGlmICghc3RydWN0dXJlKSByZXR1cm4gZmFsc2VcblxuICB0cnkge1xuICAgIC8vIDEuIElmIHRoaXMgc3RydWN0dXJlIGhhcyBjaGlsZCBzdHJ1Y3R1cmVzLCBkZWxldGUgdGhlbSByZWN1cnNpdmVseSBmaXJzdFxuICAgIGlmIChzdHJ1Y3R1cmUuY2hpbGRTdHJ1Y3R1cmVJZHMgJiYgc3RydWN0dXJlLmNoaWxkU3RydWN0dXJlSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbZGVsZXRlU3RydWN0dXJlXSBEZWxldGluZyAke3N0cnVjdHVyZS5jaGlsZFN0cnVjdHVyZUlkcy5sZW5ndGh9IGNoaWxkIHN0cnVjdHVyZXMgZm9yICR7c3RydWN0dXJlLm5hbWV9YClcbiAgICAgIGZvciAoY29uc3QgY2hpbGRJZCBvZiBzdHJ1Y3R1cmUuY2hpbGRTdHJ1Y3R1cmVJZHMpIHtcbiAgICAgICAgYXdhaXQgZGVsZXRlU3RydWN0dXJlKGNoaWxkSWQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMi4gRGVsZXRlIGFsbCBpbnZlc3RvcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RydWN0dXJlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB7IGdldEludmVzdG9yc0J5RnVuZElkLCBkZWxldGVJbnZlc3RvciB9ID0gYXdhaXQgaW1wb3J0KCcuL2ludmVzdG9ycy1zdG9yYWdlJylcbiAgICAgIGNvbnN0IGFzc29jaWF0ZWRJbnZlc3RvcnMgPSBnZXRJbnZlc3RvcnNCeUZ1bmRJZChpZClcblxuICAgICAgZm9yIChjb25zdCBpbnZlc3RvciBvZiBhc3NvY2lhdGVkSW52ZXN0b3JzKSB7XG4gICAgICAgIGRlbGV0ZUludmVzdG9yKGludmVzdG9yLmlkKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDIuNS4gRGVsZXRlIGFsbCBjYXBpdGFsIGNhbGxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0cnVjdHVyZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgeyBnZXRDYXBpdGFsQ2FsbHNCeUZ1bmRJZCwgZGVsZXRlQ2FwaXRhbENhbGwgfSA9IGF3YWl0IGltcG9ydCgnLi9jYXBpdGFsLWNhbGxzLXN0b3JhZ2UnKVxuICAgICAgY29uc3QgYXNzb2NpYXRlZENhcGl0YWxDYWxscyA9IGdldENhcGl0YWxDYWxsc0J5RnVuZElkKGlkKVxuXG4gICAgICBmb3IgKGNvbnN0IGNhcGl0YWxDYWxsIG9mIGFzc29jaWF0ZWRDYXBpdGFsQ2FsbHMpIHtcbiAgICAgICAgZGVsZXRlQ2FwaXRhbENhbGwoY2FwaXRhbENhbGwuaWQpXG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgW2RlbGV0ZVN0cnVjdHVyZV0gRGVsZXRlZCAke2Fzc29jaWF0ZWRDYXBpdGFsQ2FsbHMubGVuZ3RofSBjYXBpdGFsIGNhbGxzIGZvciAke3N0cnVjdHVyZS5uYW1lfWApXG4gICAgfVxuXG4gICAgLy8gMi42LiBEZWxldGUgYWxsIGRpc3RyaWJ1dGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RydWN0dXJlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB7IGdldERpc3RyaWJ1dGlvbnNCeUZ1bmRJZCwgZGVsZXRlRGlzdHJpYnV0aW9uIH0gPSBhd2FpdCBpbXBvcnQoJy4vZGlzdHJpYnV0aW9ucy1zdG9yYWdlJylcbiAgICAgIGNvbnN0IGFzc29jaWF0ZWREaXN0cmlidXRpb25zID0gZ2V0RGlzdHJpYnV0aW9uc0J5RnVuZElkKGlkKVxuXG4gICAgICBmb3IgKGNvbnN0IGRpc3RyaWJ1dGlvbiBvZiBhc3NvY2lhdGVkRGlzdHJpYnV0aW9ucykge1xuICAgICAgICBkZWxldGVEaXN0cmlidXRpb24oZGlzdHJpYnV0aW9uLmlkKVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYFtkZWxldGVTdHJ1Y3R1cmVdIERlbGV0ZWQgJHthc3NvY2lhdGVkRGlzdHJpYnV0aW9ucy5sZW5ndGh9IGRpc3RyaWJ1dGlvbnMgZm9yICR7c3RydWN0dXJlLm5hbWV9YClcbiAgICB9XG5cbiAgICAvLyAzLiBEZWxldGUgdXBsb2FkZWQgZG9jdW1lbnRzIGZyb20gZmlsZXN5c3RlbSAoQVBJIGNhbGwpXG4gICAgaWYgKHN0cnVjdHVyZS51cGxvYWRlZEZ1bmREb2N1bWVudHM/Lmxlbmd0aCB8fCBzdHJ1Y3R1cmUudXBsb2FkZWRJbnZlc3RvckRvY3VtZW50cz8ubGVuZ3RoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZXRjaChgL2FwaS9zdHJ1Y3R1cmVzLyR7aWR9L2RvY3VtZW50c2AsIHtcbiAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZGVsZXRlIHVwbG9hZGVkIGRvY3VtZW50czonLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBJZiB0aGlzIHN0cnVjdHVyZSBoYXMgYSBwYXJlbnQsIHJlbW92ZSBpdCBmcm9tIHBhcmVudCdzIGNoaWxkU3RydWN0dXJlSWRzXG4gICAgaWYgKHN0cnVjdHVyZS5wYXJlbnRTdHJ1Y3R1cmVJZCkge1xuICAgICAgY29uc3QgdXBkYXRlZFN0cnVjdHVyZXMgPSBnZXRTdHJ1Y3R1cmVzKClcbiAgICAgIGNvbnN0IHBhcmVudCA9IHVwZGF0ZWRTdHJ1Y3R1cmVzLmZpbmQocyA9PiBzLmlkID09PSBzdHJ1Y3R1cmUucGFyZW50U3RydWN0dXJlSWQpXG4gICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5jaGlsZFN0cnVjdHVyZUlkcykge1xuICAgICAgICBwYXJlbnQuY2hpbGRTdHJ1Y3R1cmVJZHMgPSBwYXJlbnQuY2hpbGRTdHJ1Y3R1cmVJZHMuZmlsdGVyKGNoaWxkSWQgPT4gY2hpbGRJZCAhPT0gaWQpXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkU3RydWN0dXJlcykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS4gRGVsZXRlIHRoZSBzdHJ1Y3R1cmUgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGdldFN0cnVjdHVyZXMoKS5maWx0ZXIocyA9PiBzLmlkICE9PSBpZClcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoZmlsdGVyZWQpKVxuXG4gICAgY29uc29sZS5sb2coYFtkZWxldGVTdHJ1Y3R1cmVdIERlbGV0ZWQgc3RydWN0dXJlOiAke3N0cnVjdHVyZS5uYW1lfSAoJHtpZH0pYClcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHN0cnVjdHVyZTonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIEdldCBhIHNpbmdsZSBzdHJ1Y3R1cmUgYnkgSURcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHJ1Y3R1cmVCeUlkKGlkOiBzdHJpbmcpOiBTdHJ1Y3R1cmUgfCBudWxsIHtcbiAgY29uc3Qgc3RydWN0dXJlcyA9IGdldFN0cnVjdHVyZXMoKVxuICByZXR1cm4gc3RydWN0dXJlcy5maW5kKHMgPT4gcy5pZCA9PT0gaWQpIHx8IG51bGxcbn1cblxuLy8gR2V0IGN1cnJlbnQgaW52ZXN0b3IgY291bnQgZm9yIGEgc3RydWN0dXJlXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RydWN0dXJlSW52ZXN0b3JDb3VudChzdHJ1Y3R1cmVJZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gMFxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBnZXRJbnZlc3RvcnNCeUZ1bmRJZCB9ID0gcmVxdWlyZSgnLi9pbnZlc3RvcnMtc3RvcmFnZScpXG4gICAgY29uc3QgaW52ZXN0b3JzID0gZ2V0SW52ZXN0b3JzQnlGdW5kSWQoc3RydWN0dXJlSWQpXG4gICAgcmV0dXJuIGludmVzdG9ycy5sZW5ndGhcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIDBcbiAgfVxufVxuXG4vLyBHZXQgY3VycmVudCBpbnZlc3RtZW50IGNvdW50IGZvciBhIHN0cnVjdHVyZVxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cnVjdHVyZUludmVzdG1lbnRDb3VudChzdHJ1Y3R1cmVJZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gMFxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBnZXRJbnZlc3RtZW50c0J5RnVuZElkIH0gPSByZXF1aXJlKCcuL2ludmVzdG1lbnRzLXN0b3JhZ2UnKVxuICAgIGNvbnN0IGludmVzdG1lbnRzID0gZ2V0SW52ZXN0bWVudHNCeUZ1bmRJZChzdHJ1Y3R1cmVJZClcbiAgICByZXR1cm4gaW52ZXN0bWVudHMubGVuZ3RoXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAwXG4gIH1cbn1cblxuLy8gQ2hlY2sgaWYgc3RydWN0dXJlIGNhbiBhY2NlcHQgbW9yZSBpbnZlc3RvcnNcbmV4cG9ydCBmdW5jdGlvbiBjYW5BZGRJbnZlc3RvcihzdHJ1Y3R1cmVJZDogc3RyaW5nKTogeyBjYW5BZGQ6IGJvb2xlYW47IGN1cnJlbnQ6IG51bWJlcjsgbWF4OiBudW1iZXIgfSB7XG4gIGNvbnN0IHN0cnVjdHVyZSA9IGdldFN0cnVjdHVyZUJ5SWQoc3RydWN0dXJlSWQpXG4gIGlmICghc3RydWN0dXJlKSByZXR1cm4geyBjYW5BZGQ6IGZhbHNlLCBjdXJyZW50OiAwLCBtYXg6IDAgfVxuXG4gIGNvbnN0IGN1cnJlbnQgPSBnZXRTdHJ1Y3R1cmVJbnZlc3RvckNvdW50KHN0cnVjdHVyZUlkKVxuICBjb25zdCBtYXggPSBzdHJ1Y3R1cmUuaW52ZXN0b3JzXG5cbiAgcmV0dXJuIHsgY2FuQWRkOiBjdXJyZW50IDwgbWF4LCBjdXJyZW50LCBtYXggfVxufVxuXG4vLyBDaGVjayBpZiBzdHJ1Y3R1cmUgY2FuIGFjY2VwdCBtb3JlIGludmVzdG1lbnRzXG5leHBvcnQgZnVuY3Rpb24gY2FuQWRkSW52ZXN0bWVudChzdHJ1Y3R1cmVJZDogc3RyaW5nKTogeyBjYW5BZGQ6IGJvb2xlYW47IGN1cnJlbnQ6IG51bWJlcjsgbWF4OiBudW1iZXIgfSB7XG4gIGNvbnN0IHN0cnVjdHVyZSA9IGdldFN0cnVjdHVyZUJ5SWQoc3RydWN0dXJlSWQpXG4gIGlmICghc3RydWN0dXJlKSByZXR1cm4geyBjYW5BZGQ6IGZhbHNlLCBjdXJyZW50OiAwLCBtYXg6IDAgfVxuXG4gIGNvbnN0IGN1cnJlbnQgPSBnZXRTdHJ1Y3R1cmVJbnZlc3RtZW50Q291bnQoc3RydWN0dXJlSWQpXG4gIGNvbnN0IG1heCA9IHBhcnNlSW50KHN0cnVjdHVyZS5wbGFubmVkSW52ZXN0bWVudHMgfHwgJzAnKVxuXG4gIHJldHVybiB7IGNhbkFkZDogY3VycmVudCA8IG1heCwgY3VycmVudCwgbWF4IH1cbn1cblxuLy8gR2V0IGN1cnJlbnQgaXNzdWFuY2UgY291bnQgZm9yIGEgc3RydWN0dXJlXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RydWN0dXJlSXNzdWFuY2VDb3VudChzdHJ1Y3R1cmVJZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gMFxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBnZXRJbnZlc3RtZW50c0J5RnVuZElkIH0gPSByZXF1aXJlKCcuL2ludmVzdG1lbnRzLXN0b3JhZ2UnKVxuICAgIGNvbnN0IGludmVzdG1lbnRzID0gZ2V0SW52ZXN0bWVudHNCeUZ1bmRJZChzdHJ1Y3R1cmVJZClcblxuICAgIGNvbnNvbGUubG9nKGBbREVCVUddIGdldFN0cnVjdHVyZUlzc3VhbmNlQ291bnQgZm9yICR7c3RydWN0dXJlSWR9OmAsIHtcbiAgICAgIGludmVzdG1lbnRzRm91bmQ6IGludmVzdG1lbnRzLmxlbmd0aCxcbiAgICAgIGludmVzdG1lbnRzOiBpbnZlc3RtZW50cy5tYXAoaW52ID0+ICh7XG4gICAgICAgIGlkOiBpbnYuaWQsXG4gICAgICAgIG5hbWU6IGludi5uYW1lLFxuICAgICAgICBmdW5kSWQ6IGludi5mdW5kSWQsXG4gICAgICAgIGludmVzdG1lbnRUeXBlOiBpbnYuaW52ZXN0bWVudFR5cGVcbiAgICAgIH0pKVxuICAgIH0pXG5cbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgaXNzdWFuY2VzIGJhc2VkIG9uIGludmVzdG1lbnQgdHlwZXNcbiAgICAvLyBNaXhlZCA9IDIgaXNzdWFuY2VzLCBFcXVpdHkgPSAxLCBEZWJ0ID0gMVxuICAgIGNvbnN0IHRvdGFsSXNzdWFuY2VzID0gaW52ZXN0bWVudHMucmVkdWNlKChzdW0sIGludikgPT4ge1xuICAgICAgY29uc3QgaW52VHlwZSA9IGludi5pbnZlc3RtZW50VHlwZT8udG9VcHBlckNhc2UoKVxuICAgICAgaWYgKGludlR5cGUgPT09ICdNSVhFRCcpIHJldHVybiBzdW0gKyAyXG4gICAgICBpZiAoaW52VHlwZSA9PT0gJ0VRVUlUWScpIHJldHVybiBzdW0gKyAxXG4gICAgICBpZiAoaW52VHlwZSA9PT0gJ0RFQlQnKSByZXR1cm4gc3VtICsgMVxuICAgICAgcmV0dXJuIHN1bVxuICAgIH0sIDApXG5cbiAgICBjb25zb2xlLmxvZyhgW0RFQlVHXSBUb3RhbCBpc3N1YW5jZXMgY2FsY3VsYXRlZDogJHt0b3RhbElzc3VhbmNlc31gKVxuXG4gICAgcmV0dXJuIHRvdGFsSXNzdWFuY2VzXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW0RFQlVHXSBFcnJvciBpbiBnZXRTdHJ1Y3R1cmVJc3N1YW5jZUNvdW50OicsIGVycm9yKVxuICAgIHJldHVybiAwXG4gIH1cbn1cblxuLy8gQ2hlY2sgaWYgc3RydWN0dXJlIGNhbiBhY2NlcHQgbW9yZSBpc3N1YW5jZXMgKGNvbnNpZGVyaW5nIHRoZSBpbnZlc3RtZW50IHR5cGUpXG5leHBvcnQgZnVuY3Rpb24gY2FuQWRkSXNzdWFuY2Uoc3RydWN0dXJlSWQ6IHN0cmluZywgaW52ZXN0bWVudFR5cGU6ICdFcXVpdHknIHwgJ0RlYnQnIHwgJ01peGVkJyk6IHsgY2FuQWRkOiBib29sZWFuOyBjdXJyZW50OiBudW1iZXI7IG1heDogbnVtYmVyOyByZXF1aXJlZDogbnVtYmVyIH0ge1xuICBjb25zdCBzdHJ1Y3R1cmUgPSBnZXRTdHJ1Y3R1cmVCeUlkKHN0cnVjdHVyZUlkKVxuICBpZiAoIXN0cnVjdHVyZSkgcmV0dXJuIHsgY2FuQWRkOiBmYWxzZSwgY3VycmVudDogMCwgbWF4OiAwLCByZXF1aXJlZDogMCB9XG5cbiAgY29uc3QgY3VycmVudCA9IGdldFN0cnVjdHVyZUlzc3VhbmNlQ291bnQoc3RydWN0dXJlSWQpXG4gIGNvbnN0IG1heCA9IHN0cnVjdHVyZS5jYWxjdWxhdGVkSXNzdWFuY2VzIHx8IDBcblxuICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgaXNzdWFuY2VzIHRoaXMgaW52ZXN0bWVudCB3b3VsZCByZXF1aXJlXG4gIGNvbnN0IHJlcXVpcmVkID0gaW52ZXN0bWVudFR5cGUgPT09ICdNaXhlZCcgPyAyIDogMVxuXG4gIHJldHVybiB7IGNhbkFkZDogKGN1cnJlbnQgKyByZXF1aXJlZCkgPD0gbWF4LCBjdXJyZW50LCBtYXgsIHJlcXVpcmVkIH1cbn1cblxuLy8gTWlncmF0aW9uIGZ1bmN0aW9uIHRvIHVwZGF0ZSBvbGQgc3RydWN0dXJlcyB3aXRoIG5ldyBmaWVsZHNcbmV4cG9ydCBmdW5jdGlvbiBtaWdyYXRlU3RydWN0dXJlcygpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm5cblxuICB0cnkge1xuICAgIGNvbnN0IHN0cnVjdHVyZXMgPSBnZXRTdHJ1Y3R1cmVzKClcbiAgICBsZXQgaGFzQ2hhbmdlcyA9IGZhbHNlXG5cbiAgICBjb25zdCBtaWdyYXRlZFN0cnVjdHVyZXMgPSBzdHJ1Y3R1cmVzLm1hcChzdHJ1Y3R1cmUgPT4ge1xuICAgICAgbGV0IG5lZWRzTWlncmF0aW9uID0gZmFsc2VcbiAgICAgIGxldCBtaWdyYXRlZFN0cnVjdHVyZSA9IHsgLi4uc3RydWN0dXJlIH1cblxuICAgICAgLy8gTWlncmF0ZSBTQS9MTEMgc3VidHlwZXMgZnJvbSBmaW5hbmNpbmctYmFzZWQgdG8gZnVuY3Rpb24tYmFzZWRcbiAgICAgIGlmIChzdHJ1Y3R1cmUudHlwZSA9PT0gJ3NhJyAmJiBbJ2VxdWl0eScsICdkZWJ0JywgJ21peGVkJ10uaW5jbHVkZXMoc3RydWN0dXJlLnN1YnR5cGUpKSB7XG4gICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlXG4gICAgICAgIG5lZWRzTWlncmF0aW9uID0gdHJ1ZVxuICAgICAgICAvLyBEZWZhdWx0IGFsbCBvbGQgc3VidHlwZXMgdG8gJ3NwdicgKFNpbmdsZS1Qcm9wZXJ0eSBFbnRpdHkpXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciBTQS9MTEMgc3RydWN0dXJlc1xuICAgICAgICBtaWdyYXRlZFN0cnVjdHVyZS5zdWJ0eXBlID0gJ3NwdidcbiAgICAgICAgY29uc29sZS5sb2coYE1pZ3JhdGVkIHN0cnVjdHVyZSBcIiR7c3RydWN0dXJlLm5hbWV9XCIgZnJvbSBTQS9MTEMgc3VidHlwZSBcIiR7c3RydWN0dXJlLnN1YnR5cGV9XCIgdG8gXCJzcHZcImApXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHN0cnVjdHVyZSBuZWVkcyBtaWdyYXRpb24gKG1pc3NpbmcgbmV3IGZpZWxkcylcbiAgICAgIGlmICghc3RydWN0dXJlLnBsYW5uZWRJbnZlc3RtZW50cykge1xuICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZVxuICAgICAgICBuZWVkc01pZ3JhdGlvbiA9IHRydWVcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdG9rZW4gdmFsdWUgKHJvdW5kIHRvIG5lYXJlc3QgMTAwMCwgMTAwMDAsIDEwMDAwMClcbiAgICAgICAgY29uc3QgYXVtID0gc3RydWN0dXJlLnRvdGFsQ29tbWl0bWVudFxuICAgICAgICBjb25zdCB0YXJnZXRUb2tlbnMgPSAxMDAwXG4gICAgICAgIGxldCB0b2tlblZhbHVlID0gTWF0aC5yb3VuZChhdW0gLyB0YXJnZXRUb2tlbnMpXG5cbiAgICAgICAgaWYgKHRva2VuVmFsdWUgPj0gMTAwMDAwKSB0b2tlblZhbHVlID0gTWF0aC5yb3VuZCh0b2tlblZhbHVlIC8gMTAwMDAwKSAqIDEwMDAwMFxuICAgICAgICBlbHNlIGlmICh0b2tlblZhbHVlID49IDEwMDAwKSB0b2tlblZhbHVlID0gTWF0aC5yb3VuZCh0b2tlblZhbHVlIC8gMTAwMDApICogMTAwMDBcbiAgICAgICAgZWxzZSBpZiAodG9rZW5WYWx1ZSA+PSAxMDAwKSB0b2tlblZhbHVlID0gTWF0aC5yb3VuZCh0b2tlblZhbHVlIC8gMTAwMCkgKiAxMDAwXG4gICAgICAgIGVsc2UgaWYgKHRva2VuVmFsdWUgPj0gMTAwKSB0b2tlblZhbHVlID0gTWF0aC5yb3VuZCh0b2tlblZhbHVlIC8gMTAwKSAqIDEwMFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0b3RhbCB0b2tlbnNcbiAgICAgICAgY29uc3QgdG90YWxUb2tlbnMgPSBNYXRoLnJvdW5kKGF1bSAvIHRva2VuVmFsdWUpXG5cbiAgICAgICAgbWlncmF0ZWRTdHJ1Y3R1cmUgPSB7XG4gICAgICAgICAgLi4ubWlncmF0ZWRTdHJ1Y3R1cmUsXG4gICAgICAgICAgLy8gQWRkIGRlZmF1bHQgdmFsdWVzIGZvciBWMyBmaWVsZHNcbiAgICAgICAgICBwbGFubmVkSW52ZXN0bWVudHM6ICcxJyxcbiAgICAgICAgICBmaW5hbmNpbmdTdHJhdGVneTogJ2VxdWl0eScsXG4gICAgICAgICAgY2FwaXRhbENhbGxOb3RpY2VQZXJpb2Q6ICcxMCcsXG4gICAgICAgICAgY2FwaXRhbENhbGxEZWZhdWx0UGVyY2VudGFnZTogJzI1JyxcbiAgICAgICAgICBjYXBpdGFsQ2FsbFBheW1lbnREZWFkbGluZTogJzE1JyxcbiAgICAgICAgICBkZXRlcm1pbmVkVGllcjogc3RydWN0dXJlLnRvdGFsQ29tbWl0bWVudCA8PSAxMDAwMDAwMCA/ICdzdGFydGVyJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0dXJlLnRvdGFsQ29tbWl0bWVudCA8PSA1MDAwMDAwMCA/ICdncm93dGgnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICBzdHJ1Y3R1cmUudG90YWxDb21taXRtZW50IDw9IDEwMDAwMDAwMCA/ICdlbnRlcnByaXNlJyA6ICdjdXN0b20nLFxuICAgICAgICAgIGNhbGN1bGF0ZWRJc3N1YW5jZXM6IDEsXG4gICAgICAgICAgdG9rZW5OYW1lOiBgJHtzdHJ1Y3R1cmUubmFtZX0gVG9rZW5gLFxuICAgICAgICAgIHRva2VuU3ltYm9sOiBzdHJ1Y3R1cmUubmFtZS5zcGxpdCgnICcpLm1hcCh3ID0+IHdbMF0pLmpvaW4oJycpLnN1YnN0cmluZygwLCA1KS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIHRva2VuVmFsdWU6IHRva2VuVmFsdWUsXG4gICAgICAgICAgdG90YWxUb2tlbnM6IHRvdGFsVG9rZW5zLFxuICAgICAgICAgIHByZVJlZ2lzdGVyZWRJbnZlc3RvcnM6IFtdLFxuICAgICAgICAgIHVwbG9hZGVkRnVuZERvY3VtZW50czogW10sXG4gICAgICAgICAgdXBsb2FkZWRJbnZlc3RvckRvY3VtZW50czogW11cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNaWdyYXRlIHRvIGhpZXJhcmNoeSBzdXBwb3J0IChhZGQgZGVmYXVsdCB2YWx1ZXMpXG4gICAgICBpZiAoc3RydWN0dXJlLmhpZXJhcmNoeU1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZVxuICAgICAgICBtaWdyYXRlZFN0cnVjdHVyZSA9IHtcbiAgICAgICAgICAuLi5taWdyYXRlZFN0cnVjdHVyZSxcbiAgICAgICAgICBoaWVyYXJjaHlNb2RlOiBmYWxzZSxcbiAgICAgICAgICBwYXJlbnRTdHJ1Y3R1cmVJZDogbnVsbCxcbiAgICAgICAgICBjaGlsZFN0cnVjdHVyZUlkczogW10sXG4gICAgICAgICAgaGllcmFyY2h5TGV2ZWw6IDAsXG4gICAgICAgICAgaGllcmFyY2h5UGF0aDogW3N0cnVjdHVyZS5pZF0sXG4gICAgICAgICAgYXBwbHlXYXRlcmZhbGxBdFRoaXNMZXZlbDogdHJ1ZSxcbiAgICAgICAgICBhcHBseUVjb25vbWljVGVybXNBdFRoaXNMZXZlbDogdHJ1ZSxcbiAgICAgICAgICB3YXRlcmZhbGxBbGdvcml0aG06IG51bGwsXG4gICAgICAgICAgaW5jb21lRmxvd1RhcmdldDogJ2ludmVzdG9ycydcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlncmF0ZWRTdHJ1Y3R1cmVcbiAgICB9KVxuXG4gICAgaWYgKGhhc0NoYW5nZXMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShtaWdyYXRlZFN0cnVjdHVyZXMpKVxuICAgICAgY29uc29sZS5sb2coJ1N0cnVjdHVyZXMgbWlncmF0ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbWlncmF0aW5nIHN0cnVjdHVyZXM6JywgZXJyb3IpXG4gIH1cbn1cblxuLy8gSGllcmFyY2h5IHV0aWxpdHkgZnVuY3Rpb25zXG5cbi8vIEdldCBmdWxsIGhpZXJhcmNoeSB0cmVlIHN0YXJ0aW5nIGZyb20gcm9vdCBzdHJ1Y3R1cmVcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHJ1Y3R1cmVIaWVyYXJjaHkocm9vdElkOiBzdHJpbmcpOiBTdHJ1Y3R1cmUgfCBudWxsIHtcbiAgY29uc3Qgc3RydWN0dXJlID0gZ2V0U3RydWN0dXJlQnlJZChyb290SWQpXG4gIGlmICghc3RydWN0dXJlKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IGJ1aWxkVHJlZSA9IChzdHJ1Y3Q6IFN0cnVjdHVyZSk6IFN0cnVjdHVyZSA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSAoc3RydWN0LmNoaWxkU3RydWN0dXJlSWRzIHx8IFtdKVxuICAgICAgLm1hcChjaGlsZElkID0+IGdldFN0cnVjdHVyZUJ5SWQoY2hpbGRJZCkpXG4gICAgICAuZmlsdGVyKChjaGlsZCk6IGNoaWxkIGlzIFN0cnVjdHVyZSA9PiBjaGlsZCAhPT0gbnVsbClcbiAgICAgIC5tYXAoY2hpbGQgPT4gYnVpbGRUcmVlKGNoaWxkKSlcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5zdHJ1Y3QsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4gYXMgYW55IC8vIEFkZCBjaGlsZHJlbiBmb3IgdHJlZSByZXByZXNlbnRhdGlvblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWlsZFRyZWUoc3RydWN0dXJlKVxufVxuXG4vLyBHZXQgYWxsIGFuY2VzdG9yIHN0cnVjdHVyZXMgdXAgdG8gcm9vdFxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cnVjdHVyZUFuY2VzdG9ycyhpZDogc3RyaW5nKTogU3RydWN0dXJlW10ge1xuICBjb25zdCBzdHJ1Y3R1cmUgPSBnZXRTdHJ1Y3R1cmVCeUlkKGlkKVxuICBpZiAoIXN0cnVjdHVyZSkgcmV0dXJuIFtdXG5cbiAgY29uc3QgYW5jZXN0b3JzOiBTdHJ1Y3R1cmVbXSA9IFtdXG4gIGxldCBjdXJyZW50ID0gc3RydWN0dXJlXG5cbiAgd2hpbGUgKGN1cnJlbnQucGFyZW50U3RydWN0dXJlSWQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBnZXRTdHJ1Y3R1cmVCeUlkKGN1cnJlbnQucGFyZW50U3RydWN0dXJlSWQpXG4gICAgaWYgKCFwYXJlbnQpIGJyZWFrXG4gICAgYW5jZXN0b3JzLnB1c2gocGFyZW50KVxuICAgIGN1cnJlbnQgPSBwYXJlbnRcbiAgfVxuXG4gIHJldHVybiBhbmNlc3RvcnMucmV2ZXJzZSgpIC8vIFJvb3QgZmlyc3Rcbn1cblxuLy8gR2V0IGFsbCBkZXNjZW5kYW50IHN0cnVjdHVyZXMgcmVjdXJzaXZlbHlcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHJ1Y3R1cmVEZXNjZW5kYW50cyhpZDogc3RyaW5nKTogU3RydWN0dXJlW10ge1xuICBjb25zdCBzdHJ1Y3R1cmUgPSBnZXRTdHJ1Y3R1cmVCeUlkKGlkKVxuICBpZiAoIXN0cnVjdHVyZSkge1xuICAgIGNvbnNvbGUubG9nKGBbZ2V0U3RydWN0dXJlRGVzY2VuZGFudHNdIFN0cnVjdHVyZSBub3QgZm91bmQgZm9yIElEOiAke2lkfWApXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBjb25zb2xlLmxvZyhgW2dldFN0cnVjdHVyZURlc2NlbmRhbnRzXSBTdGFydGluZyB3aXRoOiAke3N0cnVjdHVyZS5uYW1lfSAoSUQ6ICR7aWR9KWApXG4gIGNvbnNvbGUubG9nKGBbZ2V0U3RydWN0dXJlRGVzY2VuZGFudHNdIGNoaWxkU3RydWN0dXJlSWRzOmAsIHN0cnVjdHVyZS5jaGlsZFN0cnVjdHVyZUlkcylcblxuICBjb25zdCBkZXNjZW5kYW50czogU3RydWN0dXJlW10gPSBbXVxuXG4gIGNvbnN0IGNvbGxlY3REZXNjZW5kYW50cyA9IChzdHJ1Y3Q6IFN0cnVjdHVyZSwgZGVwdGggPSAwKSA9PiB7XG4gICAgY29uc3QgaW5kZW50ID0gJyAgJy5yZXBlYXQoZGVwdGgpXG4gICAgY29uc29sZS5sb2coYCR7aW5kZW50fVtjb2xsZWN0RGVzY2VuZGFudHNdIENoZWNraW5nOiAke3N0cnVjdC5uYW1lfSAoTGV2ZWwgJHtzdHJ1Y3QuaGllcmFyY2h5TGV2ZWx9KWApXG4gICAgY29uc29sZS5sb2coYCR7aW5kZW50fSAgY2hpbGRTdHJ1Y3R1cmVJZHM6YCwgc3RydWN0LmNoaWxkU3RydWN0dXJlSWRzKVxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSAoc3RydWN0LmNoaWxkU3RydWN0dXJlSWRzIHx8IFtdKVxuICAgICAgLm1hcChjaGlsZElkID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBnZXRTdHJ1Y3R1cmVCeUlkKGNoaWxkSWQpXG4gICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnR9ICBXQVJOSU5HOiBDaGlsZCBzdHJ1Y3R1cmUgbm90IGZvdW5kIGZvciBJRDogJHtjaGlsZElkfWApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9KVxuICAgICAgLmZpbHRlcigoY2hpbGQpOiBjaGlsZCBpcyBTdHJ1Y3R1cmUgPT4gY2hpbGQgIT09IG51bGwpXG5cbiAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnR9ICBGb3VuZCAke2NoaWxkcmVuLmxlbmd0aH0gY2hpbGRyZW5gKVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnR9ICBBZGRpbmcgY2hpbGQ6ICR7Y2hpbGQubmFtZX0gKExldmVsICR7Y2hpbGQuaGllcmFyY2h5TGV2ZWx9KWApXG4gICAgICBkZXNjZW5kYW50cy5wdXNoKGNoaWxkKVxuICAgICAgY29sbGVjdERlc2NlbmRhbnRzKGNoaWxkLCBkZXB0aCArIDEpXG4gICAgfSlcbiAgfVxuXG4gIGNvbGxlY3REZXNjZW5kYW50cyhzdHJ1Y3R1cmUpXG4gIGNvbnNvbGUubG9nKGBbZ2V0U3RydWN0dXJlRGVzY2VuZGFudHNdIFRvdGFsIGRlc2NlbmRhbnRzIGZvdW5kOiAke2Rlc2NlbmRhbnRzLmxlbmd0aH1gKVxuICByZXR1cm4gZGVzY2VuZGFudHNcbn1cblxuLy8gVmFsaWRhdGUgaGllcmFyY2h5IGludGVncml0eSAobm8gY2lyY3VsYXIgcmVmZXJlbmNlcylcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUhpZXJhcmNoeUludGVncml0eShpZDogc3RyaW5nKTogeyB2YWxpZDogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gIGNvbnN0IHN0cnVjdHVyZSA9IGdldFN0cnVjdHVyZUJ5SWQoaWQpXG4gIGlmICghc3RydWN0dXJlKSByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnU3RydWN0dXJlIG5vdCBmb3VuZCcgfVxuXG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IHdhbGtpbmcgdXAgdGhlIHRyZWVcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGxldCBjdXJyZW50ID0gc3RydWN0dXJlXG5cbiAgd2hpbGUgKGN1cnJlbnQucGFyZW50U3RydWN0dXJlSWQpIHtcbiAgICBpZiAodmlzaXRlZC5oYXMoY3VycmVudC5pZCkpIHtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6IGBDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQgYXQgJHtjdXJyZW50Lm5hbWV9YCB9XG4gICAgfVxuICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnQuaWQpXG5cbiAgICBjb25zdCBwYXJlbnQgPSBnZXRTdHJ1Y3R1cmVCeUlkKGN1cnJlbnQucGFyZW50U3RydWN0dXJlSWQpXG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6IGBQYXJlbnQgc3RydWN0dXJlICR7Y3VycmVudC5wYXJlbnRTdHJ1Y3R1cmVJZH0gbm90IGZvdW5kYCB9XG4gICAgfVxuICAgIGN1cnJlbnQgPSBwYXJlbnRcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGhpZXJhcmNoeSBwYXRoIG1hdGNoZXMgYWN0dWFsIHBhcmVudCBjaGFpblxuICBjb25zdCBhbmNlc3RvcnMgPSBnZXRTdHJ1Y3R1cmVBbmNlc3RvcnMoaWQpXG4gIGNvbnN0IGV4cGVjdGVkUGF0aCA9IFsuLi5hbmNlc3RvcnMubWFwKGEgPT4gYS5pZCksIGlkXVxuICBjb25zdCBhY3R1YWxQYXRoID0gc3RydWN0dXJlLmhpZXJhcmNoeVBhdGggfHwgW11cblxuICBpZiAoSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRQYXRoKSAhPT0gSlNPTi5zdHJpbmdpZnkoYWN0dWFsUGF0aCkpIHtcbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnSGllcmFyY2h5IHBhdGggbWlzbWF0Y2gnIH1cbiAgfVxuXG4gIHJldHVybiB7IHZhbGlkOiB0cnVlIH1cbn1cblxuLy8gR2V0IGluY29tZSBmbG93IHBhdGggZnJvbSBwcm9wZXJ0eSB0byBpbnZlc3RvcnNcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmNvbWVGbG93UGF0aChwcm9wZXJ0eUlkOiBzdHJpbmcpOiB7IHBhdGg6IFN0cnVjdHVyZVtdOyBmbG93RGVzY3JpcHRpb246IHN0cmluZyB9IHtcbiAgY29uc3Qgc3RydWN0dXJlID0gZ2V0U3RydWN0dXJlQnlJZChwcm9wZXJ0eUlkKVxuICBpZiAoIXN0cnVjdHVyZSkgcmV0dXJuIHsgcGF0aDogW10sIGZsb3dEZXNjcmlwdGlvbjogJ0ludmFsaWQgc3RydWN0dXJlJyB9XG5cbiAgY29uc3QgYW5jZXN0b3JzID0gZ2V0U3RydWN0dXJlQW5jZXN0b3JzKHByb3BlcnR5SWQpXG4gIGNvbnN0IHBhdGggPSBbc3RydWN0dXJlLCAuLi5hbmNlc3RvcnNdXG5cbiAgY29uc3QgZmxvd1N0ZXBzID0gcGF0aC5tYXAocyA9PiBzLm5hbWUpLmpvaW4oJyDihpIgJylcbiAgY29uc3QgZmxvd0Rlc2NyaXB0aW9uID0gYCR7Zmxvd1N0ZXBzfSDihpIgSW52ZXN0b3JzYFxuXG4gIHJldHVybiB7IHBhdGgsIGZsb3dEZXNjcmlwdGlvbiB9XG59XG5cbi8vIFJlcGFpciBoaWVyYXJjaHkgcmVsYXRpb25zaGlwcyBmb3IgZXhpc3Rpbmcgc3RydWN0dXJlc1xuLy8gVGhpcyBmdW5jdGlvbiByZWJ1aWxkcyBjaGlsZFN0cnVjdHVyZUlkcyBhcnJheXMgYmFzZWQgb24gcGFyZW50U3RydWN0dXJlSWQgcmVmZXJlbmNlc1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGFpckhpZXJhcmNoeVJlbGF0aW9uc2hpcHMoKTogeyByZXBhaXJlZDogbnVtYmVyOyBlcnJvcnM6IHN0cmluZ1tdIH0ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB7IHJlcGFpcmVkOiAwLCBlcnJvcnM6IFtdIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHN0cnVjdHVyZXMgPSBnZXRTdHJ1Y3R1cmVzKClcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW11cbiAgICBsZXQgcmVwYWlyZWQgPSAwXG5cbiAgICBjb25zb2xlLmxvZygnW3JlcGFpckhpZXJhcmNoeVJlbGF0aW9uc2hpcHNdIFN0YXJ0aW5nIHJlcGFpci4uLicpXG4gICAgY29uc29sZS5sb2coJ1tyZXBhaXJIaWVyYXJjaHlSZWxhdGlvbnNoaXBzXSBUb3RhbCBzdHJ1Y3R1cmVzOicsIHN0cnVjdHVyZXMubGVuZ3RoKVxuXG4gICAgLy8gRmlyc3QsIGluaXRpYWxpemUgYWxsIGNoaWxkU3RydWN0dXJlSWRzIGFycmF5c1xuICAgIHN0cnVjdHVyZXMuZm9yRWFjaChzID0+IHtcbiAgICAgIGlmICghcy5jaGlsZFN0cnVjdHVyZUlkcykge1xuICAgICAgICBzLmNoaWxkU3RydWN0dXJlSWRzID0gW11cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGNoaWxkU3RydWN0dXJlSWRzIHRvIHJlYnVpbGQgZnJvbSBzY3JhdGNoXG4gICAgICAgIHMuY2hpbGRTdHJ1Y3R1cmVJZHMgPSBbXVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBSZWJ1aWxkIGNoaWxkU3RydWN0dXJlSWRzIGJhc2VkIG9uIHBhcmVudFN0cnVjdHVyZUlkIHJlZmVyZW5jZXNcbiAgICBzdHJ1Y3R1cmVzLmZvckVhY2goc3RydWN0dXJlID0+IHtcbiAgICAgIGlmIChzdHJ1Y3R1cmUucGFyZW50U3RydWN0dXJlSWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtyZXBhaXJIaWVyYXJjaHlSZWxhdGlvbnNoaXBzXSBQcm9jZXNzaW5nOiAke3N0cnVjdHVyZS5uYW1lfWApXG4gICAgICAgIGNvbnNvbGUubG9nKGAgIHBhcmVudFN0cnVjdHVyZUlkOiAke3N0cnVjdHVyZS5wYXJlbnRTdHJ1Y3R1cmVJZH1gKVxuICAgICAgICBjb25zb2xlLmxvZyhgICBoaWVyYXJjaHlMZXZlbDogJHtzdHJ1Y3R1cmUuaGllcmFyY2h5TGV2ZWx9YClcblxuICAgICAgICBjb25zdCBwYXJlbnQgPSBzdHJ1Y3R1cmVzLmZpbmQocyA9PiBzLmlkID09PSBzdHJ1Y3R1cmUucGFyZW50U3RydWN0dXJlSWQpXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBpZiAoIXBhcmVudC5jaGlsZFN0cnVjdHVyZUlkcyEuaW5jbHVkZXMoc3RydWN0dXJlLmlkKSkge1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkU3RydWN0dXJlSWRzIS5wdXNoKHN0cnVjdHVyZS5pZClcbiAgICAgICAgICAgIHJlcGFpcmVkKytcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgIOKckyBBZGRlZCB0byBwYXJlbnQ6ICR7cGFyZW50Lm5hbWV9YClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBgUGFyZW50IHN0cnVjdHVyZSBub3QgZm91bmQ6ICR7c3RydWN0dXJlLnBhcmVudFN0cnVjdHVyZUlkfSBmb3IgY2hpbGQgJHtzdHJ1Y3R1cmUubmFtZX1gXG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgICDinJcgJHtlcnJvcn1gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFNhdmUgcmVwYWlyZWQgc3RydWN0dXJlc1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzdHJ1Y3R1cmVzKSlcblxuICAgIGNvbnNvbGUubG9nKCdbcmVwYWlySGllcmFyY2h5UmVsYXRpb25zaGlwc10gUmVwYWlyIGNvbXBsZXRlIScpXG4gICAgY29uc29sZS5sb2coYCAgUmVsYXRpb25zaGlwcyByZXBhaXJlZDogJHtyZXBhaXJlZH1gKVxuICAgIGNvbnNvbGUubG9nKGAgIEVycm9yczogJHtlcnJvcnMubGVuZ3RofWApXG5cbiAgICByZXR1cm4geyByZXBhaXJlZCwgZXJyb3JzIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbcmVwYWlySGllcmFyY2h5UmVsYXRpb25zaGlwc10gRXJyb3IgZHVyaW5nIHJlcGFpcjonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIENyZWF0ZSBzYW1wbGUgbXVsdGktbGV2ZWwgaGllcmFyY2h5IHN0cnVjdHVyZXMgZm9yIHRlc3RpbmdcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTYW1wbGVIaWVyYXJjaGllcygpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm5cblxuICBjb25zb2xlLmxvZygnW2NyZWF0ZVNhbXBsZUhpZXJhcmNoaWVzXSBDcmVhdGluZyBzYW1wbGUgbXVsdGktbGV2ZWwgaGllcmFyY2hpZXMuLi4nKVxuXG4gIC8vIEdldCBleGlzdGluZyBzdHJ1Y3R1cmVzXG4gIGNvbnN0IGV4aXN0aW5nID0gZ2V0U3RydWN0dXJlcygpXG5cbiAgLy8gQ2hlY2sgaWYgaGllcmFyY2hpZXMgYWxyZWFkeSBleGlzdFxuICBjb25zdCBoYXNIaWVyYXJjaGllcyA9IGV4aXN0aW5nLnNvbWUocyA9PiBzLmhpZXJhcmNoeU1vZGUgJiYgcy5oaWVyYXJjaHlMZXZlbCAmJiBzLmhpZXJhcmNoeUxldmVsID4gMSlcblxuICBpZiAoaGFzSGllcmFyY2hpZXMpIHtcbiAgICBjb25zb2xlLmxvZygnW2NyZWF0ZVNhbXBsZUhpZXJhcmNoaWVzXSBNdWx0aS1sZXZlbCBoaWVyYXJjaGllcyBhbHJlYWR5IGV4aXN0LiBTa2lwcGluZyBjcmVhdGlvbi4nKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gQ3JlYXRlIFBvbGliaXQgUmVhbCBFc3RhdGUgSUkgKDQgbGV2ZWxzKSAtIE5vdyB1c2VzIGF1dG9tYXRpYyBjcmVhdGlvbiFcbiAgY29uc29sZS5sb2coJ1xcbltjcmVhdGVTYW1wbGVIaWVyYXJjaGllc10gQ3JlYXRpbmcgUG9saWJpdCBSZWFsIEVzdGF0ZSBJSSAoNCBsZXZlbHMpLi4uJylcbiAgc2F2ZVN0cnVjdHVyZSh7XG4gICAgbmFtZTogJ1BvbGliaXQgUmVhbCBFc3RhdGUgSUknLFxuICAgIHR5cGU6ICdmaWRlaWNvbWlzbycsXG4gICAgc3VidHlwZTogJ3JlYWwtZXN0YXRlLXRydXN0JyxcbiAgICBqdXJpc2RpY3Rpb246ICdQYW5hbWEnLFxuICAgIHRvdGFsQ29tbWl0bWVudDogNTAwMDAwMDAsXG4gICAgY3VycmVuY3k6ICdVU0QnLFxuICAgIGludmVzdG9yczogODAsXG4gICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICBoaWVyYXJjaHlNb2RlOiB0cnVlLCAvLyBUaGlzIHRyaWdnZXJzIGF1dG9tYXRpYyBtdWx0aS1sZXZlbCBjcmVhdGlvbiFcbiAgICBoaWVyYXJjaHlMZXZlbDogMSxcbiAgICBhcHBseVdhdGVyZmFsbEF0VGhpc0xldmVsOiB0cnVlLFxuICAgIGFwcGx5RWNvbm9taWNUZXJtc0F0VGhpc0xldmVsOiB0cnVlLFxuICAgIHdhdGVyZmFsbEFsZ29yaXRobTogJ2FtZXJpY2FuJyxcbiAgICBpbmNvbWVGbG93VGFyZ2V0OiAnaW52ZXN0b3JzJyxcbiAgICBtYW5hZ2VtZW50RmVlOiAnMicsXG4gICAgcGVyZm9ybWFuY2VGZWU6ICcyMCcsXG4gICAgaHVyZGxlUmF0ZTogJzgnLFxuICAgIHByZWZlcnJlZFJldHVybjogJzgnLFxuICAgIHBsYW5uZWRJbnZlc3RtZW50czogJzEwJyxcbiAgICBjYWxjdWxhdGVkSXNzdWFuY2VzOiAxMCxcbiAgfSlcblxuICAvLyBDcmVhdGUgUG9saWJpdCBSZWFsIEVzdGF0ZSBJSUkgKDQgbGV2ZWxzKSAtIE5vdyB1c2VzIGF1dG9tYXRpYyBjcmVhdGlvbiFcbiAgY29uc29sZS5sb2coJ1xcbltjcmVhdGVTYW1wbGVIaWVyYXJjaGllc10gQ3JlYXRpbmcgUG9saWJpdCBSZWFsIEVzdGF0ZSBJSUkgKDQgbGV2ZWxzKS4uLicpXG4gIHNhdmVTdHJ1Y3R1cmUoe1xuICAgIG5hbWU6ICdQb2xpYml0IFJlYWwgRXN0YXRlIElJSScsXG4gICAgdHlwZTogJ2ZpZGVpY29taXNvJyxcbiAgICBzdWJ0eXBlOiAncmVhbC1lc3RhdGUtdHJ1c3QnLFxuICAgIGp1cmlzZGljdGlvbjogJ1BhbmFtYScsXG4gICAgdG90YWxDb21taXRtZW50OiA1MDAwMDAwMCxcbiAgICBjdXJyZW5jeTogJ1VTRCcsXG4gICAgaW52ZXN0b3JzOiA4MCxcbiAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgIGhpZXJhcmNoeU1vZGU6IHRydWUsIC8vIFRoaXMgdHJpZ2dlcnMgYXV0b21hdGljIG11bHRpLWxldmVsIGNyZWF0aW9uIVxuICAgIGhpZXJhcmNoeUxldmVsOiAxLFxuICAgIGFwcGx5V2F0ZXJmYWxsQXRUaGlzTGV2ZWw6IHRydWUsXG4gICAgYXBwbHlFY29ub21pY1Rlcm1zQXRUaGlzTGV2ZWw6IHRydWUsXG4gICAgd2F0ZXJmYWxsQWxnb3JpdGhtOiAnYW1lcmljYW4nLFxuICAgIGluY29tZUZsb3dUYXJnZXQ6ICdpbnZlc3RvcnMnLFxuICAgIG1hbmFnZW1lbnRGZWU6ICcyJyxcbiAgICBwZXJmb3JtYW5jZUZlZTogJzIwJyxcbiAgICBodXJkbGVSYXRlOiAnOCcsXG4gICAgcHJlZmVycmVkUmV0dXJuOiAnOCcsXG4gICAgcGxhbm5lZEludmVzdG1lbnRzOiAnMTAnLFxuICAgIGNhbGN1bGF0ZWRJc3N1YW5jZXM6IDEwLFxuICB9KVxuXG4gIGNvbnNvbGUubG9nKCdcXG5bY3JlYXRlU2FtcGxlSGllcmFyY2hpZXNdIOKchSBTYW1wbGUgaGllcmFyY2hpZXMgY3JlYXRlZCBzdWNjZXNzZnVsbHkhJylcbiAgY29uc29sZS5sb2coJyAgLSBQb2xpYml0IFJlYWwgRXN0YXRlIElJOiA0IGxldmVscyAoYXV0b21hdGljKScpXG4gIGNvbnNvbGUubG9nKCcgIC0gUG9saWJpdCBSZWFsIEVzdGF0ZSBJSUk6IDQgbGV2ZWxzIChhdXRvbWF0aWMpJylcbiAgY29uc29sZS5sb2coJyAgLSBJbnZlc3RhYmxlIGxldmVsczogTGV2ZWwgMSBhbmQgTGV2ZWwgMiAod2l0aCBlY29ub21pYyB0ZXJtcyAmIHdhdGVyZmFsbCknKVxuICBjb25zb2xlLmxvZygnICAtIE9wZXJhdGlvbmFsIGxldmVsczogTGV2ZWwgMyBhbmQgTGV2ZWwgNCAobm8gaW52ZXN0b3IgcGFydGljaXBhdGlvbiknKVxufVxuXG4vLyBOQVYgKE5ldCBBc3NldCBWYWx1ZSkgTWFuYWdlbWVudCBGdW5jdGlvbnNcbmV4cG9ydCBpbnRlcmZhY2UgTmF2VXBkYXRlIHtcbiAgZGF0ZTogc3RyaW5nXG4gIHRvdGFsTmF2OiBudW1iZXJcbiAgbmF2UGVyU2hhcmU/OiBudW1iZXJcbiAgbm90ZXM/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVN0cnVjdHVyZU5hdihcbiAgc3RydWN0dXJlSWQ6IHN0cmluZyxcbiAgbmF2RGF0YTogeyB0b3RhbE5hdjogbnVtYmVyOyBuYXZQZXJTaGFyZT86IG51bWJlcjsgbm90ZXM/OiBzdHJpbmcgfVxuKTogU3RydWN0dXJlIHwgbnVsbCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ3VwZGF0ZVN0cnVjdHVyZU5hdjogd2luZG93IGlzIHVuZGVmaW5lZCcpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHN0cnVjdHVyZXMgPSBnZXRTdHJ1Y3R1cmVzKClcbiAgY29uc3QgaW5kZXggPSBzdHJ1Y3R1cmVzLmZpbmRJbmRleChzID0+IHMuaWQgPT09IHN0cnVjdHVyZUlkKVxuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICBjb25zb2xlLmVycm9yKCd1cGRhdGVTdHJ1Y3R1cmVOYXY6IFN0cnVjdHVyZSBub3QgZm91bmQgd2l0aCBJRDonLCBzdHJ1Y3R1cmVJZClcbiAgICBjb25zb2xlLmxvZygnQXZhaWxhYmxlIHN0cnVjdHVyZSBJRHM6Jywgc3RydWN0dXJlcy5tYXAocyA9PiBzLmlkKSlcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3Qgc3RydWN0dXJlID0gc3RydWN0dXJlc1tpbmRleF1cblxuICAvLyBJbml0aWFsaXplIG5hdkhpc3RvcnkgaWYgaXQgZG9lc24ndCBleGlzdFxuICBpZiAoIXN0cnVjdHVyZS5uYXZIaXN0b3J5KSB7XG4gICAgc3RydWN0dXJlLm5hdkhpc3RvcnkgPSBbXVxuICB9XG5cbiAgLy8gQ3JlYXRlIG5ldyBOQVYgZW50cnlcbiAgY29uc3QgbmF2RW50cnk6IE5hdlVwZGF0ZSA9IHtcbiAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdG90YWxOYXY6IG5hdkRhdGEudG90YWxOYXYsXG4gICAgbmF2UGVyU2hhcmU6IG5hdkRhdGEubmF2UGVyU2hhcmUsXG4gICAgbm90ZXM6IG5hdkRhdGEubm90ZXNcbiAgfVxuXG4gIC8vIEFkZCB0byBoaXN0b3J5XG4gIHN0cnVjdHVyZS5uYXZIaXN0b3J5LnB1c2gobmF2RW50cnkpXG5cbiAgLy8gVXBkYXRlIGN1cnJlbnQgTkFWXG4gIHN0cnVjdHVyZS5jdXJyZW50TmF2ID0gbmF2RGF0YS50b3RhbE5hdlxuXG4gIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gIHN0cnVjdHVyZXNbaW5kZXhdID0gc3RydWN0dXJlXG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHN0cnVjdHVyZXMpKVxuICAgIHJldHVybiBzdHJ1Y3R1cmVcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBOQVY6JywgZXJyb3IpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RydWN0dXJlTmF2SGlzdG9yeShzdHJ1Y3R1cmVJZDogc3RyaW5nKTogTmF2VXBkYXRlW10ge1xuICBjb25zdCBzdHJ1Y3R1cmUgPSBnZXRTdHJ1Y3R1cmVCeUlkKHN0cnVjdHVyZUlkKVxuICBpZiAoIXN0cnVjdHVyZSkgcmV0dXJuIFtdXG4gIHJldHVybiBzdHJ1Y3R1cmUubmF2SGlzdG9yeSB8fCBbXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlTmF2RW50cnkoc3RydWN0dXJlSWQ6IHN0cmluZywgZW50cnlEYXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBzdHJ1Y3R1cmVzID0gZ2V0U3RydWN0dXJlcygpXG4gIGNvbnN0IGluZGV4ID0gc3RydWN0dXJlcy5maW5kSW5kZXgocyA9PiBzLmlkID09PSBzdHJ1Y3R1cmVJZClcblxuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBzdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmVzW2luZGV4XVxuXG4gIGlmICghc3RydWN0dXJlLm5hdkhpc3RvcnkpIHJldHVybiBmYWxzZVxuXG4gIC8vIEZpbHRlciBvdXQgdGhlIGVudHJ5IHdpdGggbWF0Y2hpbmcgZGF0ZVxuICBjb25zdCBvcmlnaW5hbExlbmd0aCA9IHN0cnVjdHVyZS5uYXZIaXN0b3J5Lmxlbmd0aFxuICBzdHJ1Y3R1cmUubmF2SGlzdG9yeSA9IHN0cnVjdHVyZS5uYXZIaXN0b3J5LmZpbHRlcihlbnRyeSA9PiBlbnRyeS5kYXRlICE9PSBlbnRyeURhdGUpXG5cbiAgaWYgKHN0cnVjdHVyZS5uYXZIaXN0b3J5Lmxlbmd0aCA9PT0gb3JpZ2luYWxMZW5ndGgpIHJldHVybiBmYWxzZVxuXG4gIC8vIFVwZGF0ZSBjdXJyZW50TmF2IHRvIHRoZSBsYXRlc3QgZW50cnksIG9yIHVuZGVmaW5lZCBpZiBubyBoaXN0b3J5XG4gIGlmIChzdHJ1Y3R1cmUubmF2SGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbGF0ZXN0TmF2ID0gc3RydWN0dXJlLm5hdkhpc3Rvcnlbc3RydWN0dXJlLm5hdkhpc3RvcnkubGVuZ3RoIC0gMV1cbiAgICBzdHJ1Y3R1cmUuY3VycmVudE5hdiA9IGxhdGVzdE5hdi50b3RhbE5hdlxuICB9IGVsc2Uge1xuICAgIHN0cnVjdHVyZS5jdXJyZW50TmF2ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICBzdHJ1Y3R1cmVzW2luZGV4XSA9IHN0cnVjdHVyZVxuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzdHJ1Y3R1cmVzKSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIE5BViBlbnRyeTonLCBlcnJvcilcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJTdHJ1Y3R1cmVzKCk6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVyblxuICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0tFWSlcbn1cbiJdLCJuYW1lcyI6WyJTVE9SQUdFX0tFWSIsImdlbmVyYXRlU2x1Z0Zyb21OYW1lIiwibmFtZSIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsImdldFN0cnVjdHVyZXMiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic3RydWN0dXJlcyIsIkpTT04iLCJwYXJzZSIsIm1hcCIsInMiLCJjcmVhdGVkRGF0ZSIsIkRhdGUiLCJpbmNlcHRpb25EYXRlIiwidW5kZWZpbmVkIiwicHJlUmVnaXN0ZXJlZEludmVzdG9ycyIsImludiIsImFkZGVkQXQiLCJ1cGxvYWRlZEZ1bmREb2N1bWVudHMiLCJkb2MiLCJ1cGxvYWRlZEludmVzdG9yRG9jdW1lbnRzIiwiZXJyb3IiLCJjb25zb2xlIiwic2F2ZVN0cnVjdHVyZSIsInN0cnVjdHVyZSIsInN1cHBvcnRzSGllcmFyY2h5IiwidHlwZSIsImhpZXJhcmNoeU1vZGUiLCJwYXJlbnRTdHJ1Y3R1cmVJZCIsImhpZXJhcmNoeUxldmVsIiwiY3JlYXRlTXVsdGlMZXZlbFN0cnVjdHVyZSIsIndhcm4iLCJzYXZlU2luZ2xlU3RydWN0dXJlIiwic2x1ZyIsImNvdW50ZXIiLCJmaW5hbFNsdWciLCJzb21lIiwiaWQiLCJuZXdTdHJ1Y3R1cmUiLCJwdXNoIiwicGFyZW50SW5kZXgiLCJmaW5kSW5kZXgiLCJjaGlsZFN0cnVjdHVyZUlkcyIsImluY2x1ZGVzIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImJhc2VTdHJ1Y3R1cmUiLCJudW1iZXJPZkxldmVscyIsImhpZXJhcmNoeUNvbmZpZyIsImhpZXJhcmNoeVN0cnVjdHVyZXMiLCJsb2ciLCJsZW5ndGgiLCJiYXNlU2x1ZyIsImNyZWF0ZWRMZXZlbHMiLCJwcmV2aW91c0xldmVsIiwibGV2ZWxOdW0iLCJsZXZlbENvbmZpZyIsImFwcGx5RWNvbm9taWNUZXJtcyIsImFwcGx5V2F0ZXJmYWxsIiwid2F0ZXJmYWxsQWxnbyIsIndhdGVyZmFsbEFsZ29yaXRobSIsImxldmVsVHlwZSIsImxldmVsU3VidHlwZSIsInN1YnR5cGUiLCJsZXZlbExhYmVsIiwibGV2ZWxOYW1lIiwiaGllcmFyY2h5UGF0aCIsImwiLCJjb21taXRtZW50TXVsdGlwbGllciIsInRvdGFsQ29tbWl0bWVudCIsIk1hdGgiLCJtYXgiLCJsZXZlbFN0cnVjdHVyZSIsImFwcGx5V2F0ZXJmYWxsQXRUaGlzTGV2ZWwiLCJhcHBseUVjb25vbWljVGVybXNBdFRoaXNMZXZlbCIsImluY29tZUZsb3dUYXJnZXQiLCJpbnZlc3RhYmlsaXR5TGFiZWwiLCJ3YXRlcmZhbGxMYWJlbCIsInJlcGFpckhpZXJhcmNoeVJlbGF0aW9uc2hpcHMiLCJzYXZlSW52ZXN0b3IiLCJyZXF1aXJlIiwiaW52ZXN0YWJsZUxldmVscyIsImZpbHRlciIsImxldmVsIiwiZm9yRWFjaCIsInByZUludmVzdG9yIiwidGFyZ2V0TGV2ZWwiLCJmb3VuZExldmVsIiwiZmluZCIsImVtYWlsIiwiaW52ZXN0b3JOYW1lIiwiaW52ZXN0b3JUeXBlIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJlbnRpdHlOYW1lIiwiY29tbWl0bWVudCIsIm93bmVyc2hpcFBlcmNlbnQiLCJwaG9uZSIsInN0YXR1cyIsImZ1bmRPd25lcnNoaXBzIiwiZnVuZElkIiwiZnVuZE5hbWUiLCJjYWxsZWRDYXBpdGFsIiwidW5jYWxsZWRDYXBpdGFsIiwiaW52ZXN0ZWREYXRlIiwidG9JU09TdHJpbmciLCJjdXN0b21UZXJtcyIsImN1cnJlbnRWYWx1ZSIsInVucmVhbGl6ZWRHYWluIiwidG90YWxEaXN0cmlidXRlZCIsIm5ldENhc2hGbG93IiwiaXJyIiwidGF4SWQiLCJrMVN0YXR1cyIsImNvdW50cnkiLCJqdXJpc2RpY3Rpb24iLCJjaXR5IiwiYWRkcmVzcyIsImludmVzdG9yU2luY2UiLCJlbnRpdHlUeXBlIiwiY29udGFjdEZpcnN0TmFtZSIsImNvbnRhY3RMYXN0TmFtZSIsInVwZGF0ZVN0cnVjdHVyZSIsInVwZGF0ZXMiLCJpbmRleCIsImRlbGV0ZVN0cnVjdHVyZSIsImNoaWxkSWQiLCJnZXRJbnZlc3RvcnNCeUZ1bmRJZCIsImRlbGV0ZUludmVzdG9yIiwiYXNzb2NpYXRlZEludmVzdG9ycyIsImludmVzdG9yIiwiZ2V0Q2FwaXRhbENhbGxzQnlGdW5kSWQiLCJkZWxldGVDYXBpdGFsQ2FsbCIsImFzc29jaWF0ZWRDYXBpdGFsQ2FsbHMiLCJjYXBpdGFsQ2FsbCIsImdldERpc3RyaWJ1dGlvbnNCeUZ1bmRJZCIsImRlbGV0ZURpc3RyaWJ1dGlvbiIsImFzc29jaWF0ZWREaXN0cmlidXRpb25zIiwiZGlzdHJpYnV0aW9uIiwiZmV0Y2giLCJtZXRob2QiLCJ1cGRhdGVkU3RydWN0dXJlcyIsInBhcmVudCIsImZpbHRlcmVkIiwiZ2V0U3RydWN0dXJlQnlJZCIsImdldFN0cnVjdHVyZUludmVzdG9yQ291bnQiLCJzdHJ1Y3R1cmVJZCIsImludmVzdG9ycyIsImdldFN0cnVjdHVyZUludmVzdG1lbnRDb3VudCIsImdldEludmVzdG1lbnRzQnlGdW5kSWQiLCJpbnZlc3RtZW50cyIsImNhbkFkZEludmVzdG9yIiwiY2FuQWRkIiwiY3VycmVudCIsImNhbkFkZEludmVzdG1lbnQiLCJwYXJzZUludCIsInBsYW5uZWRJbnZlc3RtZW50cyIsImdldFN0cnVjdHVyZUlzc3VhbmNlQ291bnQiLCJpbnZlc3RtZW50c0ZvdW5kIiwiaW52ZXN0bWVudFR5cGUiLCJ0b3RhbElzc3VhbmNlcyIsInJlZHVjZSIsInN1bSIsImludlR5cGUiLCJ0b1VwcGVyQ2FzZSIsImNhbkFkZElzc3VhbmNlIiwicmVxdWlyZWQiLCJjYWxjdWxhdGVkSXNzdWFuY2VzIiwibWlncmF0ZVN0cnVjdHVyZXMiLCJoYXNDaGFuZ2VzIiwibWlncmF0ZWRTdHJ1Y3R1cmVzIiwibmVlZHNNaWdyYXRpb24iLCJtaWdyYXRlZFN0cnVjdHVyZSIsImF1bSIsInRhcmdldFRva2VucyIsInRva2VuVmFsdWUiLCJyb3VuZCIsInRvdGFsVG9rZW5zIiwiZmluYW5jaW5nU3RyYXRlZ3kiLCJjYXBpdGFsQ2FsbE5vdGljZVBlcmlvZCIsImNhcGl0YWxDYWxsRGVmYXVsdFBlcmNlbnRhZ2UiLCJjYXBpdGFsQ2FsbFBheW1lbnREZWFkbGluZSIsImRldGVybWluZWRUaWVyIiwidG9rZW5OYW1lIiwidG9rZW5TeW1ib2wiLCJzcGxpdCIsInciLCJqb2luIiwic3Vic3RyaW5nIiwiZ2V0U3RydWN0dXJlSGllcmFyY2h5Iiwicm9vdElkIiwiYnVpbGRUcmVlIiwic3RydWN0IiwiY2hpbGRyZW4iLCJjaGlsZCIsImdldFN0cnVjdHVyZUFuY2VzdG9ycyIsImFuY2VzdG9ycyIsInJldmVyc2UiLCJnZXRTdHJ1Y3R1cmVEZXNjZW5kYW50cyIsImRlc2NlbmRhbnRzIiwiY29sbGVjdERlc2NlbmRhbnRzIiwiZGVwdGgiLCJpbmRlbnQiLCJyZXBlYXQiLCJ2YWxpZGF0ZUhpZXJhcmNoeUludGVncml0eSIsInZhbGlkIiwidmlzaXRlZCIsIlNldCIsImhhcyIsImFkZCIsImV4cGVjdGVkUGF0aCIsImEiLCJhY3R1YWxQYXRoIiwiZ2V0SW5jb21lRmxvd1BhdGgiLCJwcm9wZXJ0eUlkIiwicGF0aCIsImZsb3dEZXNjcmlwdGlvbiIsImZsb3dTdGVwcyIsInJlcGFpcmVkIiwiZXJyb3JzIiwiY3JlYXRlU2FtcGxlSGllcmFyY2hpZXMiLCJleGlzdGluZyIsImhhc0hpZXJhcmNoaWVzIiwiY3VycmVuY3kiLCJtYW5hZ2VtZW50RmVlIiwicGVyZm9ybWFuY2VGZWUiLCJodXJkbGVSYXRlIiwicHJlZmVycmVkUmV0dXJuIiwidXBkYXRlU3RydWN0dXJlTmF2IiwibmF2RGF0YSIsIm5hdkhpc3RvcnkiLCJuYXZFbnRyeSIsImRhdGUiLCJ0b3RhbE5hdiIsIm5hdlBlclNoYXJlIiwibm90ZXMiLCJjdXJyZW50TmF2IiwiZ2V0U3RydWN0dXJlTmF2SGlzdG9yeSIsImRlbGV0ZU5hdkVudHJ5IiwiZW50cnlEYXRlIiwib3JpZ2luYWxMZW5ndGgiLCJlbnRyeSIsImxhdGVzdE5hdiIsImNsZWFyU3RydWN0dXJlcyIsInJlbW92ZUl0ZW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/structures-storage.ts\n"));

/***/ })

});