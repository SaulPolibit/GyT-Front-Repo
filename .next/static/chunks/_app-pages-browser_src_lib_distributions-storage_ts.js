"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_distributions-storage_ts"],{

/***/ "(app-pages-browser)/./src/lib/distributions-storage.ts":
/*!******************************************!*\
  !*** ./src/lib/distributions-storage.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDistribution: () => (/* binding */ deleteDistribution),\n/* harmony export */   getDistributionById: () => (/* binding */ getDistributionById),\n/* harmony export */   getDistributionSummary: () => (/* binding */ getDistributionSummary),\n/* harmony export */   getDistributions: () => (/* binding */ getDistributions),\n/* harmony export */   getDistributionsByDateRange: () => (/* binding */ getDistributionsByDateRange),\n/* harmony export */   getDistributionsByFundId: () => (/* binding */ getDistributionsByFundId),\n/* harmony export */   getDistributionsBySource: () => (/* binding */ getDistributionsBySource),\n/* harmony export */   getDistributionsByStatus: () => (/* binding */ getDistributionsByStatus),\n/* harmony export */   getNextDistributionNumber: () => (/* binding */ getNextDistributionNumber),\n/* harmony export */   getUpcomingDistributions: () => (/* binding */ getUpcomingDistributions),\n/* harmony export */   markDistributionAsCompleted: () => (/* binding */ markDistributionAsCompleted),\n/* harmony export */   markDistributionAsProcessing: () => (/* binding */ markDistributionAsProcessing),\n/* harmony export */   saveDistribution: () => (/* binding */ saveDistribution),\n/* harmony export */   updateDistribution: () => (/* binding */ updateDistribution),\n/* harmony export */   updateInvestorDistribution: () => (/* binding */ updateInvestorDistribution)\n/* harmony export */ });\nconst STORAGE_KEY = 'polibit_distributions';\n// Get all distributions from localStorage\nfunction getDistributions() {\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(STORAGE_KEY);\n        if (!stored) return [];\n        return JSON.parse(stored);\n    } catch (error) {\n        console.error('Error loading distributions:', error);\n        return [];\n    }\n}\n// Save a new distribution\nfunction saveDistribution(distribution) {\n    const distributions = getDistributions();\n    const now = new Date().toISOString();\n    const newId = \"dist-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n    // Ensure ID is unique\n    let finalId = newId;\n    while(distributions.some((d)=>d.id === finalId)){\n        finalId = \"dist-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n    }\n    const newDistribution = {\n        ...distribution,\n        id: finalId,\n        createdAt: now,\n        updatedAt: now\n    };\n    distributions.push(newDistribution);\n    try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(distributions));\n    } catch (error) {\n        console.error('Error saving distribution:', error);\n        throw error;\n    }\n    return newDistribution;\n}\n// Update an existing distribution\nfunction updateDistribution(id, updates) {\n    const distributions = getDistributions();\n    const index = distributions.findIndex((d)=>d.id === id);\n    if (index === -1) return null;\n    distributions[index] = {\n        ...distributions[index],\n        ...updates,\n        updatedAt: new Date().toISOString()\n    };\n    try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(distributions));\n    } catch (error) {\n        console.error('Error updating distribution:', error);\n        throw error;\n    }\n    return distributions[index];\n}\n// Delete a distribution\nfunction deleteDistribution(id) {\n    const distributions = getDistributions();\n    const filtered = distributions.filter((d)=>d.id !== id);\n    if (filtered.length === distributions.length) return false;\n    try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(filtered));\n        return true;\n    } catch (error) {\n        console.error('Error deleting distribution:', error);\n        throw error;\n    }\n}\n// Get a single distribution by ID\nfunction getDistributionById(id) {\n    const distributions = getDistributions();\n    return distributions.find((d)=>d.id === id) || null;\n}\n// Get distributions by fund ID\nfunction getDistributionsByFundId(fundId) {\n    const distributions = getDistributions();\n    return distributions.filter((d)=>d.fundId === fundId);\n}\n// Get distributions by status\nfunction getDistributionsByStatus(status) {\n    const distributions = getDistributions();\n    return distributions.filter((d)=>d.status === status);\n}\n// Get distributions by source\nfunction getDistributionsBySource(source) {\n    const distributions = getDistributions();\n    return distributions.filter((d)=>d.source === source);\n}\n// Get next distribution number for a fund\nfunction getNextDistributionNumber(fundId) {\n    const fundDistributions = getDistributionsByFundId(fundId);\n    if (fundDistributions.length === 0) return 1;\n    const maxDistNumber = Math.max(...fundDistributions.map((d)=>d.distributionNumber));\n    return maxDistNumber + 1;\n}\n// Update payment status for an investor allocation\nfunction updateInvestorDistribution(distributionId, investorId, status, paymentDetails) {\n    const distribution = getDistributionById(distributionId);\n    if (!distribution) return null;\n    const allocationIndex = distribution.investorAllocations.findIndex((alloc)=>alloc.investorId === investorId);\n    if (allocationIndex === -1) return null;\n    distribution.investorAllocations[allocationIndex] = {\n        ...distribution.investorAllocations[allocationIndex],\n        status,\n        processedDate: status === 'Completed' ? new Date().toISOString() : undefined,\n        ...paymentDetails\n    };\n    // Update distribution status if all allocations are completed\n    const allCompleted = distribution.investorAllocations.every((alloc)=>alloc.status === 'Completed');\n    const anyProcessing = distribution.investorAllocations.some((alloc)=>alloc.status === 'Processing');\n    let newStatus = distribution.status;\n    if (allCompleted) {\n        newStatus = 'Completed';\n    } else if (anyProcessing) {\n        newStatus = 'Processing';\n    }\n    return updateDistribution(distributionId, {\n        investorAllocations: distribution.investorAllocations,\n        status: newStatus,\n        processedDate: allCompleted ? new Date().toISOString() : undefined\n    });\n}\n// Mark distribution as processing\nfunction markDistributionAsProcessing(distributionId) {\n    return updateDistribution(distributionId, {\n        status: 'Processing'\n    });\n}\n// Mark distribution as completed\nfunction markDistributionAsCompleted(distributionId) {\n    return updateDistribution(distributionId, {\n        status: 'Completed',\n        processedDate: new Date().toISOString()\n    });\n}\n// Get upcoming distributions (next 30 days)\nfunction getUpcomingDistributions() {\n    const distributions = getDistributions();\n    const now = new Date();\n    const thirtyDaysFromNow = new Date();\n    thirtyDaysFromNow.setDate(now.getDate() + 30);\n    return distributions.filter((d)=>{\n        if (d.status === 'Completed') return false;\n        const distDate = new Date(d.distributionDate);\n        return distDate >= now && distDate <= thirtyDaysFromNow;\n    }).sort((a, b)=>new Date(a.distributionDate).getTime() - new Date(b.distributionDate).getTime());\n}\n// Get summary statistics\nfunction getDistributionSummary() {\n    const distributions = getDistributions();\n    return {\n        total: distributions.length,\n        pending: distributions.filter((d)=>d.status === 'Pending').length,\n        processing: distributions.filter((d)=>d.status === 'Processing').length,\n        completed: distributions.filter((d)=>d.status === 'Completed').length,\n        failed: distributions.filter((d)=>d.status === 'Failed').length,\n        upcoming: getUpcomingDistributions().length,\n        totalDistributionAmount: distributions.reduce((sum, d)=>sum + d.totalDistributionAmount, 0),\n        totalReturnOfCapital: distributions.reduce((sum, d)=>sum + (d.returnOfCapitalAmount || 0), 0),\n        totalIncome: distributions.reduce((sum, d)=>sum + (d.incomeAmount || 0), 0),\n        totalCapitalGain: distributions.reduce((sum, d)=>sum + (d.capitalGainAmount || 0), 0)\n    };\n}\n// Get distributions by date range\nfunction getDistributionsByDateRange(startDate, endDate) {\n    const distributions = getDistributions();\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    return distributions.filter((d)=>{\n        const distDate = new Date(d.distributionDate);\n        return distDate >= start && distDate <= end;\n    }).sort((a, b)=>new Date(b.distributionDate).getTime() - new Date(a.distributionDate).getTime());\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZGlzdHJpYnV0aW9ucy1zdG9yYWdlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLE1BQU1BLGNBQWM7QUFFcEIsMENBQTBDO0FBQ25DLFNBQVNDO0lBQ2QsSUFBSSxLQUE2QixFQUFFLEVBQVM7SUFFNUMsSUFBSTtRQUNGLE1BQU1DLFNBQVNDLGFBQWFDLE9BQU8sQ0FBQ0o7UUFDcEMsSUFBSSxDQUFDRSxRQUFRLE9BQU8sRUFBRTtRQUN0QixPQUFPRyxLQUFLQyxLQUFLLENBQUNKO0lBQ3BCLEVBQUUsT0FBT0ssT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsZ0NBQWdDQTtRQUM5QyxPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRUEsMEJBQTBCO0FBQ25CLFNBQVNFLGlCQUFpQkMsWUFBa0U7SUFDakcsTUFBTUMsZ0JBQWdCVjtJQUV0QixNQUFNVyxNQUFNLElBQUlDLE9BQU9DLFdBQVc7SUFDbEMsTUFBTUMsUUFBUSxRQUFzQkMsT0FBZEgsS0FBS0QsR0FBRyxJQUFHLEtBQThDLE9BQTNDSSxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRztJQUU1RSxzQkFBc0I7SUFDdEIsSUFBSUMsVUFBVUw7SUFDZCxNQUFPSixjQUFjVSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLEVBQUUsS0FBS0gsU0FBVTtRQUNoREEsVUFBVSxRQUFzQkosT0FBZEgsS0FBS0QsR0FBRyxJQUFHLEtBQThDLE9BQTNDSSxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRztJQUMxRTtJQUVBLE1BQU1LLGtCQUFnQztRQUNwQyxHQUFHZCxZQUFZO1FBQ2ZhLElBQUlIO1FBQ0pLLFdBQVdiO1FBQ1hjLFdBQVdkO0lBQ2I7SUFFQUQsY0FBY2dCLElBQUksQ0FBQ0g7SUFFbkIsSUFBSTtRQUNGckIsYUFBYXlCLE9BQU8sQ0FBQzVCLGFBQWFL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QzdGQyxhQUFhOUUsY0FBYzBFLE1BQU0sQ0FBQyxDQUFDQyxLQUFLaEUsSUFBTWdFLE1BQU9oRSxDQUFBQSxFQUFFb0UsWUFBWSxJQUFJLElBQUk7UUFDM0VDLGtCQUFrQmhGLGNBQWMwRSxNQUFNLENBQUMsQ0FBQ0MsS0FBS2hFLElBQU1nRSxNQUFPaEUsQ0FBQUEsRUFBRXNFLGlCQUFpQixJQUFJLElBQUk7SUFDdkY7QUFDRjtBQUVBLGtDQUFrQztBQUMzQixTQUFTQyw0QkFBNEJDLFNBQWlCLEVBQUVDLE9BQWU7SUFDNUUsTUFBTXBGLGdCQUFnQlY7SUFDdEIsTUFBTStGLFFBQVEsSUFBSW5GLEtBQUtpRjtJQUN2QixNQUFNRyxNQUFNLElBQUlwRixLQUFLa0Y7SUFFckIsT0FBT3BGLGNBQWN5QixNQUFNLENBQUNkLENBQUFBO1FBQzFCLE1BQU1pRCxXQUFXLElBQUkxRCxLQUFLUyxFQUFFa0QsZ0JBQWdCO1FBQzVDLE9BQU9ELFlBQVl5QixTQUFTekIsWUFBWTBCO0lBQzFDLEdBQUd4QixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTSxJQUFJOUQsS0FBSzhELEVBQUVILGdCQUFnQixFQUFFSSxPQUFPLEtBQUssSUFBSS9ELEtBQUs2RCxFQUFFRixnQkFBZ0IsRUFBRUksT0FBTztBQUNqRyIsInNvdXJjZXMiOlsiL1VzZXJzL21hcnNhbmVtL0RvY3VtZW50cy9HaXRIdWIvZGVtby9zcmMvbGliL2Rpc3RyaWJ1dGlvbnMtc3RvcmFnZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IERpc3RyaWJ1dGlvbiwgRGlzdHJpYnV0aW9uU3RhdHVzLCBEaXN0cmlidXRpb25Tb3VyY2UgfSBmcm9tICcuL3R5cGVzJ1xuXG4vLyBSZS1leHBvcnQgdHlwZXMgZm9yIGNvbnZlbmllbmNlXG5leHBvcnQgdHlwZSB7IERpc3RyaWJ1dGlvbiwgRGlzdHJpYnV0aW9uU3RhdHVzLCBEaXN0cmlidXRpb25Tb3VyY2UgfVxuXG5jb25zdCBTVE9SQUdFX0tFWSA9ICdwb2xpYml0X2Rpc3RyaWJ1dGlvbnMnXG5cbi8vIEdldCBhbGwgZGlzdHJpYnV0aW9ucyBmcm9tIGxvY2FsU3RvcmFnZVxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RyaWJ1dGlvbnMoKTogRGlzdHJpYnV0aW9uW10ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVkpXG4gICAgaWYgKCFzdG9yZWQpIHJldHVybiBbXVxuICAgIHJldHVybiBKU09OLnBhcnNlKHN0b3JlZClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGRpc3RyaWJ1dGlvbnM6JywgZXJyb3IpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuLy8gU2F2ZSBhIG5ldyBkaXN0cmlidXRpb25cbmV4cG9ydCBmdW5jdGlvbiBzYXZlRGlzdHJpYnV0aW9uKGRpc3RyaWJ1dGlvbjogT21pdDxEaXN0cmlidXRpb24sICdpZCcgfCAnY3JlYXRlZEF0JyB8ICd1cGRhdGVkQXQnPik6IERpc3RyaWJ1dGlvbiB7XG4gIGNvbnN0IGRpc3RyaWJ1dGlvbnMgPSBnZXREaXN0cmlidXRpb25zKClcblxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgY29uc3QgbmV3SWQgPSBgZGlzdC0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpfWBcblxuICAvLyBFbnN1cmUgSUQgaXMgdW5pcXVlXG4gIGxldCBmaW5hbElkID0gbmV3SWRcbiAgd2hpbGUgKGRpc3RyaWJ1dGlvbnMuc29tZShkID0+IGQuaWQgPT09IGZpbmFsSWQpKSB7XG4gICAgZmluYWxJZCA9IGBkaXN0LSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSl9YFxuICB9XG5cbiAgY29uc3QgbmV3RGlzdHJpYnV0aW9uOiBEaXN0cmlidXRpb24gPSB7XG4gICAgLi4uZGlzdHJpYnV0aW9uLFxuICAgIGlkOiBmaW5hbElkLFxuICAgIGNyZWF0ZWRBdDogbm93LFxuICAgIHVwZGF0ZWRBdDogbm93LFxuICB9XG5cbiAgZGlzdHJpYnV0aW9ucy5wdXNoKG5ld0Rpc3RyaWJ1dGlvbilcblxuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShkaXN0cmlidXRpb25zKSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgZGlzdHJpYnV0aW9uOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cblxuICByZXR1cm4gbmV3RGlzdHJpYnV0aW9uXG59XG5cbi8vIFVwZGF0ZSBhbiBleGlzdGluZyBkaXN0cmlidXRpb25cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEaXN0cmlidXRpb24oaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxEaXN0cmlidXRpb24+KTogRGlzdHJpYnV0aW9uIHwgbnVsbCB7XG4gIGNvbnN0IGRpc3RyaWJ1dGlvbnMgPSBnZXREaXN0cmlidXRpb25zKClcbiAgY29uc3QgaW5kZXggPSBkaXN0cmlidXRpb25zLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGlkKVxuXG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBudWxsXG5cbiAgZGlzdHJpYnV0aW9uc1tpbmRleF0gPSB7XG4gICAgLi4uZGlzdHJpYnV0aW9uc1tpbmRleF0sXG4gICAgLi4udXBkYXRlcyxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoZGlzdHJpYnV0aW9ucykpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgZGlzdHJpYnV0aW9uOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cblxuICByZXR1cm4gZGlzdHJpYnV0aW9uc1tpbmRleF1cbn1cblxuLy8gRGVsZXRlIGEgZGlzdHJpYnV0aW9uXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlRGlzdHJpYnV0aW9uKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgZGlzdHJpYnV0aW9ucyA9IGdldERpc3RyaWJ1dGlvbnMoKVxuICBjb25zdCBmaWx0ZXJlZCA9IGRpc3RyaWJ1dGlvbnMuZmlsdGVyKGQgPT4gZC5pZCAhPT0gaWQpXG5cbiAgaWYgKGZpbHRlcmVkLmxlbmd0aCA9PT0gZGlzdHJpYnV0aW9ucy5sZW5ndGgpIHJldHVybiBmYWxzZVxuXG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGZpbHRlcmVkKSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGRpc3RyaWJ1dGlvbjonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIEdldCBhIHNpbmdsZSBkaXN0cmlidXRpb24gYnkgSURcbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0cmlidXRpb25CeUlkKGlkOiBzdHJpbmcpOiBEaXN0cmlidXRpb24gfCBudWxsIHtcbiAgY29uc3QgZGlzdHJpYnV0aW9ucyA9IGdldERpc3RyaWJ1dGlvbnMoKVxuICByZXR1cm4gZGlzdHJpYnV0aW9ucy5maW5kKGQgPT4gZC5pZCA9PT0gaWQpIHx8IG51bGxcbn1cblxuLy8gR2V0IGRpc3RyaWJ1dGlvbnMgYnkgZnVuZCBJRFxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RyaWJ1dGlvbnNCeUZ1bmRJZChmdW5kSWQ6IHN0cmluZyk6IERpc3RyaWJ1dGlvbltdIHtcbiAgY29uc3QgZGlzdHJpYnV0aW9ucyA9IGdldERpc3RyaWJ1dGlvbnMoKVxuICByZXR1cm4gZGlzdHJpYnV0aW9ucy5maWx0ZXIoZCA9PiBkLmZ1bmRJZCA9PT0gZnVuZElkKVxufVxuXG4vLyBHZXQgZGlzdHJpYnV0aW9ucyBieSBzdGF0dXNcbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0cmlidXRpb25zQnlTdGF0dXMoc3RhdHVzOiBEaXN0cmlidXRpb25TdGF0dXMpOiBEaXN0cmlidXRpb25bXSB7XG4gIGNvbnN0IGRpc3RyaWJ1dGlvbnMgPSBnZXREaXN0cmlidXRpb25zKClcbiAgcmV0dXJuIGRpc3RyaWJ1dGlvbnMuZmlsdGVyKGQgPT4gZC5zdGF0dXMgPT09IHN0YXR1cylcbn1cblxuLy8gR2V0IGRpc3RyaWJ1dGlvbnMgYnkgc291cmNlXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdHJpYnV0aW9uc0J5U291cmNlKHNvdXJjZTogRGlzdHJpYnV0aW9uU291cmNlKTogRGlzdHJpYnV0aW9uW10ge1xuICBjb25zdCBkaXN0cmlidXRpb25zID0gZ2V0RGlzdHJpYnV0aW9ucygpXG4gIHJldHVybiBkaXN0cmlidXRpb25zLmZpbHRlcihkID0+IGQuc291cmNlID09PSBzb3VyY2UpXG59XG5cbi8vIEdldCBuZXh0IGRpc3RyaWJ1dGlvbiBudW1iZXIgZm9yIGEgZnVuZFxuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHREaXN0cmlidXRpb25OdW1iZXIoZnVuZElkOiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBmdW5kRGlzdHJpYnV0aW9ucyA9IGdldERpc3RyaWJ1dGlvbnNCeUZ1bmRJZChmdW5kSWQpXG4gIGlmIChmdW5kRGlzdHJpYnV0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiAxXG5cbiAgY29uc3QgbWF4RGlzdE51bWJlciA9IE1hdGgubWF4KC4uLmZ1bmREaXN0cmlidXRpb25zLm1hcChkID0+IGQuZGlzdHJpYnV0aW9uTnVtYmVyKSlcbiAgcmV0dXJuIG1heERpc3ROdW1iZXIgKyAxXG59XG5cbi8vIFVwZGF0ZSBwYXltZW50IHN0YXR1cyBmb3IgYW4gaW52ZXN0b3IgYWxsb2NhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUludmVzdG9yRGlzdHJpYnV0aW9uKFxuICBkaXN0cmlidXRpb25JZDogc3RyaW5nLFxuICBpbnZlc3RvcklkOiBzdHJpbmcsXG4gIHN0YXR1czogJ1BlbmRpbmcnIHwgJ1Byb2Nlc3NpbmcnIHwgJ0NvbXBsZXRlZCcgfCAnRmFpbGVkJyxcbiAgcGF5bWVudERldGFpbHM/OiB7XG4gICAgcGF5bWVudE1ldGhvZD86IHN0cmluZ1xuICAgIHRyYW5zYWN0aW9uUmVmZXJlbmNlPzogc3RyaW5nXG4gICAgYmFua0RldGFpbHM/OiBzdHJpbmdcbiAgfVxuKTogRGlzdHJpYnV0aW9uIHwgbnVsbCB7XG4gIGNvbnN0IGRpc3RyaWJ1dGlvbiA9IGdldERpc3RyaWJ1dGlvbkJ5SWQoZGlzdHJpYnV0aW9uSWQpXG4gIGlmICghZGlzdHJpYnV0aW9uKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IGFsbG9jYXRpb25JbmRleCA9IGRpc3RyaWJ1dGlvbi5pbnZlc3RvckFsbG9jYXRpb25zLmZpbmRJbmRleChcbiAgICBhbGxvYyA9PiBhbGxvYy5pbnZlc3RvcklkID09PSBpbnZlc3RvcklkXG4gIClcblxuICBpZiAoYWxsb2NhdGlvbkluZGV4ID09PSAtMSkgcmV0dXJuIG51bGxcblxuICBkaXN0cmlidXRpb24uaW52ZXN0b3JBbGxvY2F0aW9uc1thbGxvY2F0aW9uSW5kZXhdID0ge1xuICAgIC4uLmRpc3RyaWJ1dGlvbi5pbnZlc3RvckFsbG9jYXRpb25zW2FsbG9jYXRpb25JbmRleF0sXG4gICAgc3RhdHVzLFxuICAgIHByb2Nlc3NlZERhdGU6IHN0YXR1cyA9PT0gJ0NvbXBsZXRlZCcgPyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgOiB1bmRlZmluZWQsXG4gICAgLi4ucGF5bWVudERldGFpbHNcbiAgfVxuXG4gIC8vIFVwZGF0ZSBkaXN0cmlidXRpb24gc3RhdHVzIGlmIGFsbCBhbGxvY2F0aW9ucyBhcmUgY29tcGxldGVkXG4gIGNvbnN0IGFsbENvbXBsZXRlZCA9IGRpc3RyaWJ1dGlvbi5pbnZlc3RvckFsbG9jYXRpb25zLmV2ZXJ5KGFsbG9jID0+IGFsbG9jLnN0YXR1cyA9PT0gJ0NvbXBsZXRlZCcpXG4gIGNvbnN0IGFueVByb2Nlc3NpbmcgPSBkaXN0cmlidXRpb24uaW52ZXN0b3JBbGxvY2F0aW9ucy5zb21lKGFsbG9jID0+IGFsbG9jLnN0YXR1cyA9PT0gJ1Byb2Nlc3NpbmcnKVxuXG4gIGxldCBuZXdTdGF0dXM6IERpc3RyaWJ1dGlvblN0YXR1cyA9IGRpc3RyaWJ1dGlvbi5zdGF0dXNcbiAgaWYgKGFsbENvbXBsZXRlZCkge1xuICAgIG5ld1N0YXR1cyA9ICdDb21wbGV0ZWQnXG4gIH0gZWxzZSBpZiAoYW55UHJvY2Vzc2luZykge1xuICAgIG5ld1N0YXR1cyA9ICdQcm9jZXNzaW5nJ1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZURpc3RyaWJ1dGlvbihkaXN0cmlidXRpb25JZCwge1xuICAgIGludmVzdG9yQWxsb2NhdGlvbnM6IGRpc3RyaWJ1dGlvbi5pbnZlc3RvckFsbG9jYXRpb25zLFxuICAgIHN0YXR1czogbmV3U3RhdHVzLFxuICAgIHByb2Nlc3NlZERhdGU6IGFsbENvbXBsZXRlZCA/IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSA6IHVuZGVmaW5lZFxuICB9KVxufVxuXG4vLyBNYXJrIGRpc3RyaWJ1dGlvbiBhcyBwcm9jZXNzaW5nXG5leHBvcnQgZnVuY3Rpb24gbWFya0Rpc3RyaWJ1dGlvbkFzUHJvY2Vzc2luZyhkaXN0cmlidXRpb25JZDogc3RyaW5nKTogRGlzdHJpYnV0aW9uIHwgbnVsbCB7XG4gIHJldHVybiB1cGRhdGVEaXN0cmlidXRpb24oZGlzdHJpYnV0aW9uSWQsIHtcbiAgICBzdGF0dXM6ICdQcm9jZXNzaW5nJ1xuICB9KVxufVxuXG4vLyBNYXJrIGRpc3RyaWJ1dGlvbiBhcyBjb21wbGV0ZWRcbmV4cG9ydCBmdW5jdGlvbiBtYXJrRGlzdHJpYnV0aW9uQXNDb21wbGV0ZWQoZGlzdHJpYnV0aW9uSWQ6IHN0cmluZyk6IERpc3RyaWJ1dGlvbiB8IG51bGwge1xuICByZXR1cm4gdXBkYXRlRGlzdHJpYnV0aW9uKGRpc3RyaWJ1dGlvbklkLCB7XG4gICAgc3RhdHVzOiAnQ29tcGxldGVkJyxcbiAgICBwcm9jZXNzZWREYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfSlcbn1cblxuLy8gR2V0IHVwY29taW5nIGRpc3RyaWJ1dGlvbnMgKG5leHQgMzAgZGF5cylcbmV4cG9ydCBmdW5jdGlvbiBnZXRVcGNvbWluZ0Rpc3RyaWJ1dGlvbnMoKTogRGlzdHJpYnV0aW9uW10ge1xuICBjb25zdCBkaXN0cmlidXRpb25zID0gZ2V0RGlzdHJpYnV0aW9ucygpXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcbiAgY29uc3QgdGhpcnR5RGF5c0Zyb21Ob3cgPSBuZXcgRGF0ZSgpXG4gIHRoaXJ0eURheXNGcm9tTm93LnNldERhdGUobm93LmdldERhdGUoKSArIDMwKVxuXG4gIHJldHVybiBkaXN0cmlidXRpb25zLmZpbHRlcihkID0+IHtcbiAgICBpZiAoZC5zdGF0dXMgPT09ICdDb21wbGV0ZWQnKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBkaXN0RGF0ZSA9IG5ldyBEYXRlKGQuZGlzdHJpYnV0aW9uRGF0ZSlcbiAgICByZXR1cm4gZGlzdERhdGUgPj0gbm93ICYmIGRpc3REYXRlIDw9IHRoaXJ0eURheXNGcm9tTm93XG4gIH0pLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGEuZGlzdHJpYnV0aW9uRGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5kaXN0cmlidXRpb25EYXRlKS5nZXRUaW1lKCkpXG59XG5cbi8vIEdldCBzdW1tYXJ5IHN0YXRpc3RpY3NcbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0cmlidXRpb25TdW1tYXJ5KCkge1xuICBjb25zdCBkaXN0cmlidXRpb25zID0gZ2V0RGlzdHJpYnV0aW9ucygpXG5cbiAgcmV0dXJuIHtcbiAgICB0b3RhbDogZGlzdHJpYnV0aW9ucy5sZW5ndGgsXG4gICAgcGVuZGluZzogZGlzdHJpYnV0aW9ucy5maWx0ZXIoZCA9PiBkLnN0YXR1cyA9PT0gJ1BlbmRpbmcnKS5sZW5ndGgsXG4gICAgcHJvY2Vzc2luZzogZGlzdHJpYnV0aW9ucy5maWx0ZXIoZCA9PiBkLnN0YXR1cyA9PT0gJ1Byb2Nlc3NpbmcnKS5sZW5ndGgsXG4gICAgY29tcGxldGVkOiBkaXN0cmlidXRpb25zLmZpbHRlcihkID0+IGQuc3RhdHVzID09PSAnQ29tcGxldGVkJykubGVuZ3RoLFxuICAgIGZhaWxlZDogZGlzdHJpYnV0aW9ucy5maWx0ZXIoZCA9PiBkLnN0YXR1cyA9PT0gJ0ZhaWxlZCcpLmxlbmd0aCxcbiAgICB1cGNvbWluZzogZ2V0VXBjb21pbmdEaXN0cmlidXRpb25zKCkubGVuZ3RoLFxuICAgIHRvdGFsRGlzdHJpYnV0aW9uQW1vdW50OiBkaXN0cmlidXRpb25zLnJlZHVjZSgoc3VtLCBkKSA9PiBzdW0gKyBkLnRvdGFsRGlzdHJpYnV0aW9uQW1vdW50LCAwKSxcbiAgICB0b3RhbFJldHVybk9mQ2FwaXRhbDogZGlzdHJpYnV0aW9ucy5yZWR1Y2UoKHN1bSwgZCkgPT4gc3VtICsgKGQucmV0dXJuT2ZDYXBpdGFsQW1vdW50IHx8IDApLCAwKSxcbiAgICB0b3RhbEluY29tZTogZGlzdHJpYnV0aW9ucy5yZWR1Y2UoKHN1bSwgZCkgPT4gc3VtICsgKGQuaW5jb21lQW1vdW50IHx8IDApLCAwKSxcbiAgICB0b3RhbENhcGl0YWxHYWluOiBkaXN0cmlidXRpb25zLnJlZHVjZSgoc3VtLCBkKSA9PiBzdW0gKyAoZC5jYXBpdGFsR2FpbkFtb3VudCB8fCAwKSwgMClcbiAgfVxufVxuXG4vLyBHZXQgZGlzdHJpYnV0aW9ucyBieSBkYXRlIHJhbmdlXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdHJpYnV0aW9uc0J5RGF0ZVJhbmdlKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcpOiBEaXN0cmlidXRpb25bXSB7XG4gIGNvbnN0IGRpc3RyaWJ1dGlvbnMgPSBnZXREaXN0cmlidXRpb25zKClcbiAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZShzdGFydERhdGUpXG4gIGNvbnN0IGVuZCA9IG5ldyBEYXRlKGVuZERhdGUpXG5cbiAgcmV0dXJuIGRpc3RyaWJ1dGlvbnMuZmlsdGVyKGQgPT4ge1xuICAgIGNvbnN0IGRpc3REYXRlID0gbmV3IERhdGUoZC5kaXN0cmlidXRpb25EYXRlKVxuICAgIHJldHVybiBkaXN0RGF0ZSA+PSBzdGFydCAmJiBkaXN0RGF0ZSA8PSBlbmRcbiAgfSkuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi5kaXN0cmlidXRpb25EYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmRpc3RyaWJ1dGlvbkRhdGUpLmdldFRpbWUoKSlcbn1cbiJdLCJuYW1lcyI6WyJTVE9SQUdFX0tFWSIsImdldERpc3RyaWJ1dGlvbnMiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjb25zb2xlIiwic2F2ZURpc3RyaWJ1dGlvbiIsImRpc3RyaWJ1dGlvbiIsImRpc3RyaWJ1dGlvbnMiLCJub3ciLCJEYXRlIiwidG9JU09TdHJpbmciLCJuZXdJZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsImZpbmFsSWQiLCJzb21lIiwiZCIsImlkIiwibmV3RGlzdHJpYnV0aW9uIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwicHVzaCIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJ1cGRhdGVEaXN0cmlidXRpb24iLCJ1cGRhdGVzIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJkZWxldGVEaXN0cmlidXRpb24iLCJmaWx0ZXJlZCIsImZpbHRlciIsImxlbmd0aCIsImdldERpc3RyaWJ1dGlvbkJ5SWQiLCJmaW5kIiwiZ2V0RGlzdHJpYnV0aW9uc0J5RnVuZElkIiwiZnVuZElkIiwiZ2V0RGlzdHJpYnV0aW9uc0J5U3RhdHVzIiwic3RhdHVzIiwiZ2V0RGlzdHJpYnV0aW9uc0J5U291cmNlIiwic291cmNlIiwiZ2V0TmV4dERpc3RyaWJ1dGlvbk51bWJlciIsImZ1bmREaXN0cmlidXRpb25zIiwibWF4RGlzdE51bWJlciIsIm1heCIsIm1hcCIsImRpc3RyaWJ1dGlvbk51bWJlciIsInVwZGF0ZUludmVzdG9yRGlzdHJpYnV0aW9uIiwiZGlzdHJpYnV0aW9uSWQiLCJpbnZlc3RvcklkIiwicGF5bWVudERldGFpbHMiLCJhbGxvY2F0aW9uSW5kZXgiLCJpbnZlc3RvckFsbG9jYXRpb25zIiwiYWxsb2MiLCJwcm9jZXNzZWREYXRlIiwidW5kZWZpbmVkIiwiYWxsQ29tcGxldGVkIiwiZXZlcnkiLCJhbnlQcm9jZXNzaW5nIiwibmV3U3RhdHVzIiwibWFya0Rpc3RyaWJ1dGlvbkFzUHJvY2Vzc2luZyIsIm1hcmtEaXN0cmlidXRpb25Bc0NvbXBsZXRlZCIsImdldFVwY29taW5nRGlzdHJpYnV0aW9ucyIsInRoaXJ0eURheXNGcm9tTm93Iiwic2V0RGF0ZSIsImdldERhdGUiLCJkaXN0RGF0ZSIsImRpc3RyaWJ1dGlvbkRhdGUiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiZ2V0RGlzdHJpYnV0aW9uU3VtbWFyeSIsInRvdGFsIiwicGVuZGluZyIsInByb2Nlc3NpbmciLCJjb21wbGV0ZWQiLCJmYWlsZWQiLCJ1cGNvbWluZyIsInRvdGFsRGlzdHJpYnV0aW9uQW1vdW50IiwicmVkdWNlIiwic3VtIiwidG90YWxSZXR1cm5PZkNhcGl0YWwiLCJyZXR1cm5PZkNhcGl0YWxBbW91bnQiLCJ0b3RhbEluY29tZSIsImluY29tZUFtb3VudCIsInRvdGFsQ2FwaXRhbEdhaW4iLCJjYXBpdGFsR2FpbkFtb3VudCIsImdldERpc3RyaWJ1dGlvbnNCeURhdGVSYW5nZSIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJzdGFydCIsImVuZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/distributions-storage.ts\n"));

/***/ })

}]);